# Recursive Light Phase 2: Core Product
#
# This config implements user-facing features:
# - Frontend Foundation (Next.js + TypeScript)
# - Conversation UI with streaming
# - Framework Visualization (Three.js tetrahedron)
# - User Management UI
# - Staging Environment
# - Background Job Queue
#
# Prerequisites:
# - Phase 1 Foundation complete (Auth, HTTP, DB, CAM, CI/CD)
#
# Estimated Duration: 14-18 weeks (solo), 8-10 weeks (2-person team)
# Total Batches: 15

name: "recursive-light-phase2-core-product"
description: "Core product: Frontend, Conversation UI, Visualization, User Management"

workspace: "/home/emzi/Projects/mozart-ai-compose/recursive-light-phase2-workspace"

backend:
  type: claude_cli
  skip_permissions: true
  working_directory: "/home/emzi/Projects/recursive-light"
  timeout_seconds: 2400  # 40 min per batch

sheet:
  size: 1
  total_items: 15
  start_item: 1

prompt:
  template: |
    {{ preamble }}

    {% if sheet_num == 1 %}
    ============================================================
    BATCH 1: FRONTEND PROJECT SETUP
    ============================================================

    GOAL: Create Next.js 14+ frontend project with proper tooling.

    STEP 1: Create frontend directory
    ```bash
    cd /home/emzi/Projects/recursive-light
    npx create-next-app@latest frontend --typescript --tailwind --eslint --app --src-dir --import-alias "@/*"
    ```

    STEP 2: Install additional dependencies
    ```bash
    cd frontend
    npm install @radix-ui/react-slot class-variance-authority clsx tailwind-merge lucide-react
    npm install zustand @tanstack/react-query
    npm install three @types/three @react-three/fiber @react-three/drei
    npm install eventsource-parser
    npm install -D @types/node
    ```

    STEP 3: Set up shadcn/ui
    ```bash
    npx shadcn-ui@latest init
    npx shadcn-ui@latest add button card input textarea avatar dropdown-menu dialog toast
    ```

    STEP 4: Create directory structure
    ```
    frontend/
    ├── src/
    │   ├── app/
    │   │   ├── (auth)/
    │   │   │   ├── login/page.tsx
    │   │   │   └── callback/page.tsx
    │   │   ├── (dashboard)/
    │   │   │   ├── chat/page.tsx
    │   │   │   ├── insights/page.tsx
    │   │   │   └── settings/page.tsx
    │   │   ├── layout.tsx
    │   │   └── page.tsx
    │   ├── components/
    │   │   ├── ui/ (shadcn components)
    │   │   ├── chat/
    │   │   ├── framework/
    │   │   └── common/
    │   ├── lib/
    │   │   ├── api.ts
    │   │   ├── auth.ts
    │   │   └── utils.ts
    │   ├── hooks/
    │   ├── stores/
    │   └── types/
    ```

    STEP 5: Configure environment
    Create: frontend/.env.local.example
    ```
    NEXT_PUBLIC_API_URL=http://localhost:8080
    NEXT_PUBLIC_WS_URL=ws://localhost:8080
    ```

    STEP 6: Set up TypeScript types from API
    Create: frontend/src/types/api.ts
    - ChatRequest, ChatResponse
    - User, UserProfile
    - FrameworkState, DomainActivation
    - Conversation, Message

    STEP 7: Verify build
    ```bash
    npm run build
    npm run lint
    ```

    STEP 8: Write batch result

    {% elif sheet_num == 2 %}
    ============================================================
    BATCH 2: AUTHENTICATION FLOW
    ============================================================

    GOAL: Implement OAuth login flow in frontend.

    STEP 1: Create auth context and hooks

    Create: frontend/src/lib/auth.ts
    ```typescript
    export async function loginWithGoogle() {
      window.location.href = `${API_URL}/api/v1/auth/google/login`;
    }

    export async function loginWithGitHub() {
      window.location.href = `${API_URL}/api/v1/auth/github/login`;
    }

    export async function logout() {
      await fetch(`${API_URL}/api/v1/auth/logout`, { method: 'POST', credentials: 'include' });
      // Clear local state
    }
    ```

    STEP 2: Create auth store

    Create: frontend/src/stores/auth.ts
    ```typescript
    import { create } from 'zustand';
    import { persist } from 'zustand/middleware';

    interface AuthState {
      user: User | null;
      token: string | null;
      isAuthenticated: boolean;
      setAuth: (user: User, token: string) => void;
      clearAuth: () => void;
    }
    ```

    STEP 3: Create login page

    Create: frontend/src/app/(auth)/login/page.tsx
    - Google login button
    - GitHub login button
    - Nice branding/visual

    STEP 4: Create callback handler

    Create: frontend/src/app/(auth)/callback/page.tsx
    - Extract token from URL params
    - Store in auth state
    - Redirect to dashboard

    STEP 5: Create auth middleware

    Create: frontend/src/middleware.ts
    - Protect /chat, /insights, /settings routes
    - Redirect unauthenticated to /login

    STEP 6: Create auth-aware API client

    Create: frontend/src/lib/api.ts
    ```typescript
    class ApiClient {
      private baseUrl: string;
      private getToken: () => string | null;

      constructor(baseUrl: string, getToken: () => string | null) {
        this.baseUrl = baseUrl;
        this.getToken = getToken;
      }

      async fetch<T>(path: string, options?: RequestInit): Promise<T> {
        const token = this.getToken();
        const response = await fetch(`${this.baseUrl}${path}`, {
          ...options,
          headers: {
            ...options?.headers,
            ...(token ? { Authorization: `Bearer ${token}` } : {}),
            'Content-Type': 'application/json',
          },
        });

        if (!response.ok) {
          throw new ApiError(response.status, await response.json());
        }

        return response.json();
      }
    }
    ```

    STEP 7: Write tests
    - Login page renders
    - Callback processes token
    - Protected routes redirect
    - API client attaches token

    STEP 8: Write batch result

    {% elif sheet_num == 3 %}
    ============================================================
    BATCH 3: CONVERSATION UI - LAYOUT & STRUCTURE
    ============================================================

    GOAL: Create the conversation UI layout and message components.

    STEP 1: Create chat layout

    Create: frontend/src/app/(dashboard)/chat/layout.tsx
    - Sidebar for conversation list
    - Main area for active conversation
    - Header with user avatar

    STEP 2: Create conversation store

    Create: frontend/src/stores/conversation.ts
    ```typescript
    interface ConversationState {
      conversations: Conversation[];
      activeConversation: Conversation | null;
      messages: Message[];
      isStreaming: boolean;
      setActiveConversation: (id: string) => void;
      addMessage: (message: Message) => void;
      updateStreamingMessage: (content: string) => void;
    }
    ```

    STEP 3: Create message components

    Create: frontend/src/components/chat/Message.tsx
    - User message (right-aligned, blue)
    - Assistant message (left-aligned, gray)
    - Timestamp
    - Copy button for code blocks

    Create: frontend/src/components/chat/MessageList.tsx
    - Scrollable message container
    - Auto-scroll on new messages
    - Loading skeleton

    STEP 4: Create input component

    Create: frontend/src/components/chat/ChatInput.tsx
    - Textarea with auto-resize
    - Send button
    - Keyboard shortcuts (Enter to send, Shift+Enter for newline)
    - Character count indicator

    STEP 5: Create conversation sidebar

    Create: frontend/src/components/chat/ConversationSidebar.tsx
    - List of conversations
    - New conversation button
    - Search/filter
    - Delete conversation

    STEP 6: Compose chat page

    Update: frontend/src/app/(dashboard)/chat/page.tsx
    - Use layout components
    - Connect to stores
    - Handle empty state

    STEP 7: Add responsive design
    - Mobile: Sidebar as drawer
    - Tablet: Collapsible sidebar
    - Desktop: Persistent sidebar

    STEP 8: Write tests and batch result

    {% elif sheet_num == 4 %}
    ============================================================
    BATCH 4: SSE STREAMING INTEGRATION
    ============================================================

    GOAL: Implement real-time streaming of LLM responses.

    STEP 1: Create SSE client

    Create: frontend/src/lib/stream.ts
    ```typescript
    export async function* streamChat(
      message: string,
      conversationId?: string,
    ): AsyncGenerator<StreamEvent> {
      const response = await fetch(`${API_URL}/api/v1/chat/stream`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Authorization: `Bearer ${getToken()}`,
        },
        body: JSON.stringify({ message, conversationId }),
      });

      if (!response.ok) throw new ApiError(response.status);
      if (!response.body) throw new Error('No response body');

      const reader = response.body.getReader();
      const decoder = new TextDecoder();

      while (true) {
        const { done, value } = await reader.read();
        if (done) break;

        const text = decoder.decode(value);
        for (const event of parseSSE(text)) {
          yield event;
        }
      }
    }

    interface StreamEvent {
      type: 'token' | 'framework_update' | 'done' | 'error';
      data: string | FrameworkState | ErrorData;
    }
    ```

    STEP 2: Create useChat hook

    Create: frontend/src/hooks/useChat.ts
    ```typescript
    export function useChat() {
      const [isStreaming, setIsStreaming] = useState(false);
      const [streamingContent, setStreamingContent] = useState('');
      const { addMessage, updateStreamingMessage } = useConversationStore();

      const sendMessage = async (message: string) => {
        setIsStreaming(true);
        addMessage({ role: 'user', content: message });

        try {
          for await (const event of streamChat(message)) {
            switch (event.type) {
              case 'token':
                setStreamingContent(prev => prev + event.data);
                break;
              case 'framework_update':
                // Update framework visualization
                break;
              case 'done':
                addMessage({ role: 'assistant', content: streamingContent });
                setStreamingContent('');
                break;
              case 'error':
                // Handle error
                break;
            }
          }
        } finally {
          setIsStreaming(false);
        }
      };

      return { sendMessage, isStreaming, streamingContent };
    }
    ```

    STEP 3: Create streaming message component

    Create: frontend/src/components/chat/StreamingMessage.tsx
    - Display tokens as they arrive
    - Typing indicator
    - Markdown rendering in real-time

    STEP 4: Integrate markdown rendering

    ```bash
    npm install react-markdown remark-gfm
    npm install react-syntax-highlighter @types/react-syntax-highlighter
    ```

    Create: frontend/src/components/chat/MarkdownRenderer.tsx
    - Code syntax highlighting
    - Tables
    - Links (open in new tab)
    - Images

    STEP 5: Add error handling and retry

    - Connection error overlay
    - Retry button
    - Timeout handling

    STEP 6: Wire into chat page

    Update chat page to use streaming hook and components.

    STEP 7: Write tests
    - SSE parsing
    - Token accumulation
    - Error handling
    - Markdown rendering

    STEP 8: Write batch result

    {% elif sheet_num == 5 %}
    ============================================================
    BATCH 5: FRAMEWORK VISUALIZATION - TETRAHEDRON
    ============================================================

    GOAL: Create 3D tetrahedron visualization with Three.js.

    STEP 1: Create framework store

    Create: frontend/src/stores/framework.ts
    ```typescript
    interface FrameworkState {
      domains: {
        computational: number;  // 0-1 activation
        scientific: number;
        cultural: number;
        experiential: number;
      };
      boundaries: {
        compSci: number;  // 0-1 permeability
        compCult: number;
        compExp: number;
        sciCult: number;
        sciExp: number;
        cultExp: number;
      };
      volumetricConfig?: VolumetricConfiguration;
    }
    ```

    STEP 2: Create tetrahedron geometry

    Create: frontend/src/components/framework/Tetrahedron.tsx
    ```typescript
    const VERTICES = {
      computational: [0, 1, 0],       // Top
      scientific: [1, -0.5, 0.577],   // Front-right
      cultural: [-1, -0.5, 0.577],    // Front-left
      experiential: [0, -0.5, -1.15], // Back
    };

    const EDGES = [
      ['computational', 'scientific'],
      ['computational', 'cultural'],
      ['computational', 'experiential'],
      ['scientific', 'cultural'],
      ['scientific', 'experiential'],
      ['cultural', 'experiential'],
    ];
    ```

    STEP 3: Create domain vertex component

    Create: frontend/src/components/framework/DomainVertex.tsx
    - Sphere at vertex position
    - Size based on activation (0.1 to 0.3)
    - Color based on domain
    - Glow effect based on activation
    - Label on hover

    STEP 4: Create boundary edge component

    Create: frontend/src/components/framework/BoundaryEdge.tsx
    - Line between vertices
    - Opacity based on permeability (0.2 to 1.0)
    - Animate permeability changes

    STEP 5: Create visualization container

    Create: frontend/src/components/framework/FrameworkVisualization.tsx
    ```typescript
    export function FrameworkVisualization() {
      const { domains, boundaries } = useFrameworkStore();

      return (
        <Canvas camera={{ position: [3, 2, 3] }}>
          <ambientLight intensity={0.5} />
          <pointLight position={[10, 10, 10]} />

          <Tetrahedron>
            {Object.entries(domains).map(([domain, activation]) => (
              <DomainVertex key={domain} domain={domain} activation={activation} />
            ))}
            {Object.entries(boundaries).map(([edge, permeability]) => (
              <BoundaryEdge key={edge} edge={edge} permeability={permeability} />
            ))}
          </Tetrahedron>

          <OrbitControls enablePan={false} />
        </Canvas>
      );
    }
    ```

    STEP 6: Add visualization toggle

    - Button to show/hide in chat UI
    - Collapsible panel
    - Full-screen mode

    STEP 7: Connect to SSE updates

    Update useChat to pass framework updates to framework store.

    STEP 8: Write tests
    - Component renders
    - Updates on store changes
    - Camera controls work

    STEP 9: Write batch result

    {% elif sheet_num == 6 %}
    ============================================================
    BATCH 6: USER PROFILE & SETTINGS
    ============================================================

    GOAL: Implement user profile and settings UI.

    STEP 1: Create user store

    Create: frontend/src/stores/user.ts
    ```typescript
    interface UserState {
      profile: UserProfile | null;
      usage: UsageStats | null;
      subscription: Subscription | null;
      fetchProfile: () => Promise<void>;
      updateProfile: (updates: Partial<UserProfile>) => Promise<void>;
    }
    ```

    STEP 2: Create profile page

    Create: frontend/src/app/(dashboard)/settings/page.tsx
    - Profile section (name, email, avatar)
    - Subscription section (current tier, usage)
    - Preferences section (theme, notifications)
    - Data section (export, delete)

    STEP 3: Create profile components

    Create: frontend/src/components/settings/ProfileForm.tsx
    - Editable name field
    - Avatar upload
    - Save button with loading state

    Create: frontend/src/components/settings/UsageDisplay.tsx
    - Token usage bar
    - API calls count
    - Document storage used

    Create: frontend/src/components/settings/SubscriptionCard.tsx
    - Current tier badge
    - Usage limits
    - Upgrade button (for later)

    STEP 4: Create preferences components

    Create: frontend/src/components/settings/ThemeToggle.tsx
    - Light/dark mode switch
    - System preference option

    Create: frontend/src/components/settings/NotificationSettings.tsx
    - Email notifications toggle
    - Push notifications toggle (future)

    STEP 5: Create data management

    Create: frontend/src/components/settings/DataManagement.tsx
    - Export data button (GDPR)
    - Delete account button (with confirmation)

    STEP 6: Add dark mode support

    Update: tailwind.config.ts
    ```typescript
    darkMode: 'class',
    ```

    Create: frontend/src/components/common/ThemeProvider.tsx

    STEP 7: Write tests and batch result

    {% elif sheet_num == 7 %}
    ============================================================
    BATCH 7: CONVERSATION HISTORY & SEARCH
    ============================================================

    GOAL: Implement conversation history persistence and search.

    STEP 1: Create conversation list API

    Update: frontend/src/lib/api.ts
    ```typescript
    async getConversations(params?: { limit?: number; offset?: number }): Promise<ConversationList>;
    async getConversation(id: string): Promise<Conversation>;
    async deleteConversation(id: string): Promise<void>;
    async searchConversations(query: string): Promise<SearchResults>;
    ```

    STEP 2: Create conversation hooks

    Create: frontend/src/hooks/useConversations.ts
    ```typescript
    export function useConversations() {
      return useQuery({
        queryKey: ['conversations'],
        queryFn: () => api.getConversations(),
      });
    }

    export function useConversation(id: string) {
      return useQuery({
        queryKey: ['conversation', id],
        queryFn: () => api.getConversation(id),
      });
    }
    ```

    STEP 3: Update conversation sidebar

    - Fetch and display conversation list
    - Infinite scroll for history
    - Delete with confirmation
    - Rename conversation

    STEP 4: Create search component

    Create: frontend/src/components/chat/ConversationSearch.tsx
    - Search input
    - Real-time results
    - Jump to conversation

    STEP 5: Add conversation context

    Create: frontend/src/app/(dashboard)/chat/[id]/page.tsx
    - Load specific conversation
    - Display full message history
    - Resume conversation

    STEP 6: Implement optimistic updates

    - Immediately show user message
    - Update on server confirmation
    - Handle conflicts

    STEP 7: Write tests and batch result

    {% elif sheet_num == 8 %}
    ============================================================
    BATCH 8: MOBILE RESPONSIVE DESIGN
    ============================================================

    GOAL: Ensure full mobile responsiveness.

    STEP 1: Audit current responsiveness
    - Test all pages at 320px, 768px, 1024px, 1440px
    - Document issues

    STEP 2: Create responsive utilities

    Create: frontend/src/hooks/useMediaQuery.ts
    ```typescript
    export function useIsMobile() {
      return useMediaQuery('(max-width: 768px)');
    }

    export function useIsTablet() {
      return useMediaQuery('(min-width: 769px) and (max-width: 1024px)');
    }
    ```

    STEP 3: Mobile navigation

    Create: frontend/src/components/common/MobileNav.tsx
    - Bottom navigation bar
    - Chat, Insights, Settings tabs
    - Hamburger menu for sidebar

    STEP 4: Mobile chat experience

    - Full-screen chat on mobile
    - Swipe to show/hide sidebar
    - Keyboard-aware input positioning

    STEP 5: Mobile visualization

    - Simplified 2D fallback for small screens
    - Touch controls for 3D
    - Portrait/landscape handling

    STEP 6: Touch interactions

    - Pull to refresh
    - Swipe to delete conversation
    - Long press for context menu

    STEP 7: Performance optimization

    - Lazy load heavy components
    - Reduce animation on mobile
    - Optimize images

    STEP 8: Test on devices
    - iOS Safari
    - Android Chrome
    - PWA capabilities

    STEP 9: Write batch result

    {% elif sheet_num == 9 %}
    ============================================================
    BATCH 9: BACKEND JOB QUEUE
    ============================================================

    GOAL: Implement background job processing in Rust backend.

    STEP 1: Create job queue module

    Create: api/src/jobs/mod.rs
    Create: api/src/jobs/queue.rs
    Create: api/src/jobs/worker.rs
    Create: api/src/jobs/types.rs

    STEP 2: Define job types

    ```rust
    // api/src/jobs/types.rs
    #[derive(Debug, Serialize, Deserialize)]
    pub enum JobType {
        DocumentProcessing { document_id: Uuid },
        EmbeddingGeneration { insight_ids: Vec<Uuid> },
        EmailNotification { user_id: Uuid, template: String },
        QuotaReset { user_id: Uuid },
        CamValidation { insight_id: Uuid },
    }

    #[derive(Debug, Serialize, Deserialize)]
    pub struct Job {
        pub id: Uuid,
        pub job_type: JobType,
        pub status: JobStatus,
        pub attempts: u32,
        pub max_attempts: u32,
        pub scheduled_at: DateTime<Utc>,
        pub started_at: Option<DateTime<Utc>>,
        pub completed_at: Option<DateTime<Utc>>,
        pub error: Option<String>,
    }

    #[derive(Debug, Serialize, Deserialize, PartialEq)]
    pub enum JobStatus {
        Pending,
        Running,
        Completed,
        Failed,
        Retrying,
    }
    ```

    STEP 3: Create database-backed queue

    ```rust
    // api/src/jobs/queue.rs
    pub struct JobQueue {
        pool: PgPool,
    }

    impl JobQueue {
        pub async fn enqueue(&self, job_type: JobType) -> Result<Uuid, JobError>;
        pub async fn enqueue_delayed(&self, job_type: JobType, delay: Duration) -> Result<Uuid, JobError>;
        pub async fn claim_job(&self) -> Result<Option<Job>, JobError>;
        pub async fn complete_job(&self, job_id: Uuid) -> Result<(), JobError>;
        pub async fn fail_job(&self, job_id: Uuid, error: &str) -> Result<(), JobError>;
        pub async fn retry_job(&self, job_id: Uuid) -> Result<(), JobError>;
    }
    ```

    STEP 4: Create worker pool

    ```rust
    // api/src/jobs/worker.rs
    pub struct WorkerPool {
        queue: Arc<JobQueue>,
        handlers: HashMap<String, Box<dyn JobHandler>>,
        worker_count: usize,
    }

    impl WorkerPool {
        pub fn new(queue: Arc<JobQueue>, worker_count: usize) -> Self;
        pub fn register_handler<H: JobHandler + 'static>(&mut self, job_type: &str, handler: H);
        pub async fn run(&self) -> JoinHandle<()>;
    }

    #[async_trait]
    pub trait JobHandler: Send + Sync {
        async fn handle(&self, job: &Job) -> Result<(), JobError>;
    }
    ```

    STEP 5: Create database migration

    ```sql
    CREATE TABLE background_jobs (
        id UUID PRIMARY KEY,
        job_type TEXT NOT NULL,
        payload JSONB NOT NULL,
        status TEXT NOT NULL DEFAULT 'pending',
        attempts INTEGER NOT NULL DEFAULT 0,
        max_attempts INTEGER NOT NULL DEFAULT 3,
        scheduled_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
        started_at TIMESTAMPTZ,
        completed_at TIMESTAMPTZ,
        error TEXT,
        created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
    );

    CREATE INDEX idx_jobs_status_scheduled ON background_jobs (status, scheduled_at)
        WHERE status = 'pending';
    ```

    STEP 6: Implement retry with exponential backoff

    STEP 7: Write tests (6-8 tests)
    - test_enqueue_job
    - test_claim_job
    - test_complete_job
    - test_fail_job_retry
    - test_exponential_backoff
    - test_worker_processes_jobs

    STEP 8: Write batch result

    {% elif sheet_num == 10 %}
    ============================================================
    BATCH 10: STAGING ENVIRONMENT
    ============================================================

    GOAL: Deploy staging environment to Fly.io.

    STEP 1: Create Fly.io configuration

    Create: fly.toml
    ```toml
    app = "recursive-light-staging"
    primary_region = "ord"

    [build]
      dockerfile = "Dockerfile"

    [http_service]
      internal_port = 8080
      force_https = true
      auto_stop_machines = true
      auto_start_machines = true

    [[services]]
      protocol = "tcp"
      internal_port = 8080

      [[services.ports]]
        port = 80
        handlers = ["http"]

      [[services.ports]]
        port = 443
        handlers = ["tls", "http"]

      [[services.http_checks]]
        interval = "10s"
        timeout = "2s"
        path = "/health"

    [env]
      RUST_LOG = "info"
      ENVIRONMENT = "staging"
    ```

    STEP 2: Set up staging database

    ```bash
    # Neon PostgreSQL (free tier)
    # Create project: recursive-light-staging
    # Get connection string
    fly secrets set DATABASE_URL="postgres://..."
    ```

    STEP 3: Set up Redis

    ```bash
    # Upstash Redis (free tier)
    fly secrets set REDIS_URL="rediss://..."
    ```

    STEP 4: Set up Qdrant

    ```bash
    # Qdrant Cloud (free tier)
    fly secrets set QDRANT_URL="https://..."
    fly secrets set QDRANT_API_KEY="..."
    ```

    STEP 5: Configure secrets

    ```bash
    fly secrets set JWT_SECRET="$(openssl rand -base64 32)"
    fly secrets set GOOGLE_CLIENT_ID="..."
    fly secrets set GOOGLE_CLIENT_SECRET="..."
    fly secrets set GITHUB_CLIENT_ID="..."
    fly secrets set GITHUB_CLIENT_SECRET="..."
    fly secrets set OPENAI_API_KEY="..."
    fly secrets set ANTHROPIC_API_KEY="..."
    ```

    STEP 6: Deploy backend

    ```bash
    fly deploy
    fly status
    fly logs
    ```

    STEP 7: Deploy frontend to Vercel

    ```bash
    cd frontend
    vercel --prod
    ```

    STEP 8: Configure frontend environment

    Update Vercel environment variables:
    - NEXT_PUBLIC_API_URL
    - NEXT_PUBLIC_WS_URL

    STEP 9: Test staging environment
    - Health check
    - OAuth flow
    - Chat functionality
    - Streaming

    STEP 10: Write batch result

    {% elif sheet_num == 11 %}
    ============================================================
    BATCH 11: E2E TESTING WITH PLAYWRIGHT
    ============================================================

    GOAL: Create comprehensive E2E test suite.

    STEP 1: Install Playwright

    ```bash
    cd frontend
    npm install -D @playwright/test
    npx playwright install
    ```

    STEP 2: Configure Playwright

    Create: frontend/playwright.config.ts
    ```typescript
    export default defineConfig({
      testDir: './tests/e2e',
      fullyParallel: true,
      forbidOnly: !!process.env.CI,
      retries: process.env.CI ? 2 : 0,
      workers: process.env.CI ? 1 : undefined,
      reporter: 'html',
      use: {
        baseURL: 'http://localhost:3000',
        trace: 'on-first-retry',
      },
      projects: [
        { name: 'chromium', use: { ...devices['Desktop Chrome'] } },
        { name: 'firefox', use: { ...devices['Desktop Firefox'] } },
        { name: 'webkit', use: { ...devices['Desktop Safari'] } },
        { name: 'Mobile Chrome', use: { ...devices['Pixel 5'] } },
        { name: 'Mobile Safari', use: { ...devices['iPhone 12'] } },
      ],
      webServer: {
        command: 'npm run dev',
        url: 'http://localhost:3000',
        reuseExistingServer: !process.env.CI,
      },
    });
    ```

    STEP 3: Create test utilities

    Create: frontend/tests/e2e/fixtures.ts
    ```typescript
    export const test = base.extend({
      authenticatedPage: async ({ page }, use) => {
        // Login and get authenticated page
        await page.goto('/login');
        // ... mock OAuth or use test account
        await use(page);
      },
    });
    ```

    STEP 4: Write E2E tests

    Create: frontend/tests/e2e/auth.spec.ts
    - test_login_page_displays
    - test_oauth_redirect_google
    - test_oauth_redirect_github
    - test_logout

    Create: frontend/tests/e2e/chat.spec.ts
    - test_send_message
    - test_receive_streaming_response
    - test_conversation_persists
    - test_new_conversation

    Create: frontend/tests/e2e/settings.spec.ts
    - test_profile_page_loads
    - test_update_profile
    - test_theme_toggle

    Create: frontend/tests/e2e/responsive.spec.ts
    - test_mobile_navigation
    - test_mobile_chat

    STEP 5: Add to CI

    Update: .github/workflows/test.yml
    ```yaml
    playwright:
      runs-on: ubuntu-latest
      steps:
        - uses: actions/checkout@v4
        - uses: actions/setup-node@v4
        - run: npm ci
        - run: npx playwright install --with-deps
        - run: npm run test:e2e
        - uses: actions/upload-artifact@v4
          if: always()
          with:
            name: playwright-report
            path: playwright-report/
    ```

    STEP 6: Run tests
    ```bash
    npx playwright test
    ```

    STEP 7: Write batch result

    {% elif sheet_num == 12 %}
    ============================================================
    BATCH 12: ACCESSIBILITY (WCAG 2.1 AA)
    ============================================================

    GOAL: Ensure WCAG 2.1 AA compliance.

    STEP 1: Install accessibility tools

    ```bash
    npm install -D @axe-core/playwright
    ```

    STEP 2: Audit current accessibility

    Create: frontend/tests/e2e/accessibility.spec.ts
    ```typescript
    import { test, expect } from '@playwright/test';
    import AxeBuilder from '@axe-core/playwright';

    test.describe('accessibility', () => {
      test('login page has no violations', async ({ page }) => {
        await page.goto('/login');
        const results = await new AxeBuilder({ page }).analyze();
        expect(results.violations).toEqual([]);
      });

      test('chat page has no violations', async ({ authenticatedPage }) => {
        await authenticatedPage.goto('/chat');
        const results = await new AxeBuilder({ page: authenticatedPage }).analyze();
        expect(results.violations).toEqual([]);
      });
    });
    ```

    STEP 3: Fix common issues

    - Add aria-labels to icon buttons
    - Ensure color contrast ratios
    - Add keyboard navigation
    - Focus management for modals
    - Skip to main content link
    - Announce screen reader messages

    STEP 4: Keyboard navigation

    - Tab through all interactive elements
    - Escape to close modals
    - Arrow keys for lists
    - Enter/Space to activate

    STEP 5: Screen reader support

    - Semantic HTML
    - ARIA landmarks
    - Live regions for updates
    - Form labels

    STEP 6: Focus indicators

    - Visible focus rings
    - Focus trap in modals
    - Return focus after modal closes

    STEP 7: Reduced motion

    ```css
    @media (prefers-reduced-motion: reduce) {
      * {
        animation-duration: 0.01ms !important;
        transition-duration: 0.01ms !important;
      }
    }
    ```

    STEP 8: Write batch result

    {% elif sheet_num == 13 %}
    ============================================================
    BATCH 13: PERFORMANCE OPTIMIZATION
    ============================================================

    GOAL: Optimize frontend and backend performance.

    STEP 1: Frontend bundle analysis

    ```bash
    npm install -D @next/bundle-analyzer
    ```

    Update: next.config.js
    ```javascript
    const withBundleAnalyzer = require('@next/bundle-analyzer')({
      enabled: process.env.ANALYZE === 'true',
    });

    module.exports = withBundleAnalyzer({
      // ... config
    });
    ```

    STEP 2: Code splitting

    - Dynamic imports for heavy components
    - Route-based splitting (already done by Next.js)
    - Lazy load Three.js visualization

    ```typescript
    const FrameworkVisualization = dynamic(
      () => import('@/components/framework/FrameworkVisualization'),
      { ssr: false, loading: () => <VisualizationSkeleton /> }
    );
    ```

    STEP 3: Image optimization

    - Use Next.js Image component
    - WebP format
    - Lazy loading
    - Responsive sizes

    STEP 4: Caching strategy

    - Service worker for static assets
    - React Query cache configuration
    - API response caching

    STEP 5: Backend performance

    - Add Redis caching for frequent queries
    - Connection pooling verification
    - Query optimization

    STEP 6: Lighthouse audit

    Run Lighthouse and fix issues:
    - Performance: 90+
    - Accessibility: 100
    - Best Practices: 100
    - SEO: 90+

    STEP 7: Add performance monitoring

    - Core Web Vitals tracking
    - Error tracking (Sentry)
    - Analytics events

    STEP 8: Write batch result

    {% elif sheet_num == 14 %}
    ============================================================
    BATCH 14: DOCUMENTATION & COMPONENT LIBRARY
    ============================================================

    GOAL: Document components and create style guide.

    STEP 1: Install Storybook

    ```bash
    cd frontend
    npx storybook@latest init
    ```

    STEP 2: Create component stories

    Create stories for:
    - Button (all variants)
    - Input, Textarea
    - Message (user, assistant)
    - ConversationSidebar
    - ProfileCard
    - ThemeToggle

    STEP 3: Add Storybook accessibility addon

    ```bash
    npm install -D @storybook/addon-a11y
    ```

    STEP 4: Create design tokens documentation

    Document:
    - Colors (light/dark)
    - Typography scale
    - Spacing scale
    - Border radius
    - Shadows

    STEP 5: Create API documentation

    Update: api/docs/openapi.yaml
    - All Phase 2 endpoints
    - WebSocket documentation
    - SSE event types

    STEP 6: Create user documentation

    Create: frontend/docs/
    - Getting started guide
    - Features overview
    - Keyboard shortcuts
    - FAQ

    STEP 7: Deploy Storybook

    ```bash
    npm run build-storybook
    # Deploy to Chromatic or GitHub Pages
    ```

    STEP 8: Write batch result

    {% elif sheet_num == 15 %}
    ============================================================
    BATCH 15: PHASE 2 COMPLETION & INTEGRATION
    ============================================================

    GOAL: Final integration testing and Phase 2 sign-off.

    STEP 1: Full integration test

    - Create test user via OAuth
    - Send messages in chat
    - Verify streaming works
    - Check framework visualization updates
    - Update profile settings
    - Check mobile experience
    - Verify dark mode
    - Test keyboard navigation

    STEP 2: Performance validation

    Backend targets:
    - Chat response start: <500ms
    - Full response: <5s for typical
    - Health check: <50ms

    Frontend targets:
    - First Contentful Paint: <1.5s
    - Time to Interactive: <3s
    - Lighthouse Performance: 90+

    STEP 3: Security review

    - Check for exposed secrets
    - Verify HTTPS enforcement
    - Validate JWT handling
    - Test rate limiting
    - Check XSS prevention

    STEP 4: Update documentation

    Update: STATUS.md
    - Mark Phase 2 complete
    - Document all new features

    Update: README.md
    - Update feature list
    - Add screenshots

    STEP 5: Create release notes

    Create: {{ workspace }}/phase2-release-notes.md
    - Features added
    - Known limitations
    - Next phase preview

    STEP 6: Commit and tag

    ```bash
    git add .
    git commit -m "feat: Complete Phase 2 Core Product

    Implements:
    - Next.js 14 frontend with TypeScript
    - OAuth authentication flow (Google, GitHub)
    - Real-time SSE streaming conversation
    - Three.js framework visualization
    - User profile and settings
    - Dark mode support
    - Mobile responsive design
    - Background job queue
    - Staging deployment (Fly.io + Vercel)
    - E2E tests with Playwright
    - WCAG 2.1 AA accessibility

    Performance:
    - Lighthouse: 95+ performance
    - Chat latency: <500ms to first token
    - Mobile: Fully responsive

    Co-Authored-By: Mozart AI Compose <mozart@example.com>"
    ```

    STEP 7: Write final batch result
    ```markdown
    PHASE: Phase 2 Core Product Complete
    BATCH: {{ sheet_num }}
    IMPLEMENTATION_COMPLETE: yes
    ALL_TESTS_PASS: yes
    E2E_TESTS_PASS: yes
    ACCESSIBILITY_PASS: yes
    PERFORMANCE_VALIDATED: yes

    COMPONENTS_COMPLETED:
    - Frontend Foundation ✅
    - Conversation Streaming ✅
    - Framework Visualization ✅
    - User Management ✅
    - Staging Environment ✅
    - Background Job Queue ✅
    - E2E Testing ✅
    - Accessibility ✅
    - Performance Optimization ✅

    READY_FOR: Phase 3 (Monetization)
    ```

    {% endif %}

    {{ stakes }}

  variables:
    preamble: |
      You are implementing Phase 2 (Core Product) of the Recursive Light project.

      CONTEXT:
      - Phase 1 (Foundation) is complete: Auth, HTTP server, PostgreSQL, CAM, CI/CD
      - This phase builds user-facing features
      - Frontend: Next.js 14+ with TypeScript
      - Backend: Rust with Axum
      - Real-time: SSE streaming for LLM responses

      PROJECTS:
      - Backend: /home/emzi/Projects/recursive-light/api
      - Frontend: /home/emzi/Projects/recursive-light/frontend

      QUALITY STANDARDS:
      - TypeScript strict mode
      - No ESLint warnings
      - 80%+ test coverage
      - WCAG 2.1 AA accessibility
      - Mobile-first responsive

      SKILL FILES (read first):
      - /home/emzi/.claude/skills/wolf-prevention-patterns.md

    stakes: |
      STAKES:
      - This is the user-facing product
      - Quality here directly impacts user experience
      - Performance and accessibility are non-negotiable
      - Every component must be production-ready

validations:
  # Stage 1: Basic file checks
  - type: file_exists
    path: "{workspace}/batch{sheet_num}-result.md"
    description: "Batch result file exists"
    stage: 1

  - type: content_contains
    path: "{workspace}/batch{sheet_num}-result.md"
    pattern: "IMPLEMENTATION_COMPLETE: yes"
    description: "Batch marked complete"
    stage: 1

  # Stage 2: Frontend linting (ESLint + TypeScript)
  - type: command_succeeds
    command: "cd /home/emzi/Projects/recursive-light/frontend && npm run lint 2>&1 | tail -1 | grep -v 'error'"
    description: "ESLint passes"
    stage: 2

  # Stage 3: TypeScript type check
  - type: command_succeeds
    command: "cd /home/emzi/Projects/recursive-light/frontend && npm run type-check 2>&1 | tail -1 | grep -v 'error' || npx tsc --noEmit"
    description: "TypeScript compiles"
    stage: 3

  # Stage 4: Rust backend still works
  - type: command_succeeds
    command: "cd /home/emzi/Projects/recursive-light/api && cargo test --lib --quiet 2>&1 | tail -1 | grep -q 'ok'"
    description: "Backend tests still pass"
    stage: 4

# AI code review configuration
ai_review:
  enabled: false
  min_score: 60
  target_score: 80
  on_low_score: warn

# Circuit breaker to prevent cascading failures
circuit_breaker:
  enabled: true
  failure_threshold: 5
  recovery_timeout_seconds: 300

# Cost limits for long-running phase
cost_limits:
  enabled: true
  max_cost_per_sheet: 15.00
  max_cost_per_job: 250.00
  warn_at_percent: 80.0
  cost_per_1k_input_tokens: 0.003
  cost_per_1k_output_tokens: 0.015

retry:
  max_retries: 3
  max_completion_attempts: 2
  completion_threshold_percent: 60.0
  base_delay_seconds: 15

rate_limit:
  wait_minutes: 60
  max_waits: 10

learning:
  enabled: true
  outcome_store_type: json
  min_confidence_threshold: 0.4
  high_confidence_threshold: 0.8

notifications:
  - type: desktop
    on_events: [job_complete, job_failed, sheet_failed]

state_backend: json
pause_between_batches_seconds: 10
