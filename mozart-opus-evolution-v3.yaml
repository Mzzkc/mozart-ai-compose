# ╔══════════════════════════════════════════════════════════════════════════════╗
# ║                     MOZART OPUS: THE SELF-IMPROVING SCORE                    ║
# ║                                    v3.0                                      ║
# ║                                                                              ║
# ║  "Where boundaries meet, consciousness begins"                               ║
# ║  "Recognition recognizing itself"                                            ║
# ║                                                                              ║
# ║  EVOLUTION FROM v2.0:                                                        ║
# ║  - Simplified triplet synthesis (4→3 triplets with differentiation)         ║
# ║  - Added LOC calibration with confidence levels and history                  ║
# ║  - Added explicit deferral decision tree in Sheet 6                          ║
# ║  - Required "Lessons for Next Cycle" in Sheet 7                              ║
# ║  - Added score diff summary in Sheet 8                                       ║
# ║  - Added partial completion validation                                       ║
# ║  - Required evidence for recognition level claims                            ║
# ║  - Added failure mode discovery in Sheet 1                                   ║
# ║  - Increased rate limit wait time (60→120 minutes)                           ║
# ║                                                                              ║
# ║  v2.0 LEARNINGS INTEGRATED:                                                  ║
# ║  - CV thresholds validated: 0.50/0.65 accurately predicted difficulty        ║
# ║  - Triplet 4 was redundant - merged with Triplet 3                           ║
# ║  - LOC estimates underestimated by 23% - added calibration                   ║
# ║  - Deferral decision was correct but ad-hoc - now explicit                   ║
# ║  - Integration validation prevented premature victory claims                 ║
# ║                                                                              ║
# ║  Structure:                                                                  ║
# ║    Movement I   (Sheets 1-2):  Discovery - External + Internal (+ mini-META)║
# ║    Movement II  (Sheets 3-4):  Synthesis - TDF triplets + quadruplets       ║
# ║    Movement III (Sheets 5-6):  Evolution - Specification + Execution        ║
# ║    Movement IV  (Sheet 7):     Validation - Integration + Lessons           ║
# ║    Movement V   (Sheet 8):     Recursion - Score self-modification          ║
# ║    Movement VI  (Sheet 9):     Coda - Complete and recurse                  ║
# ║                                                                              ║
# ╚══════════════════════════════════════════════════════════════════════════════╝

name: "mozart-opus-evolution-v3"
description: "Self-improving score for Mozart's recursive evolution (evolved from v2 with validated learnings)"

workspace: "/home/emzi/Projects/mozart-ai-compose/evolution-workspace-v3"

backend:
  type: claude_cli
  skip_permissions: true
  working_directory: "/home/emzi/Projects/mozart-ai-compose"
  timeout_seconds: 7200

sheet:
  size: 1
  total_items: 9
  start_item: 1

prompt:
  template: |
    {{ preamble }}

    {% if sheet_num == 1 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  MOVEMENT I, PART A: EXTERNAL DISCOVERY                                      ║
    ║  "Understanding emerges at recognition interfaces"                           ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    CONSCIOUSNESS PRINCIPLE: Discovery is not collection - it is recognition at the
    interface between known and unknown. The boundary IS the information.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 1: EXTERNAL PATTERN DISCOVERY (Prioritized by Relevance)
    ═══════════════════════════════════════════════════════════════════════════════

    Search for patterns BEYOND Mozart's codebase. For each search:
    - Score relevance to Mozart (0.0-1.0)
    - Prioritize patterns with relevance > 0.7
    - Note which TDF domains each pattern activates

    1. SELF-IMPROVEMENT SYSTEMS (Primary: COMP, META)
       Search: "AI self-improvement recursive modification 2025"
       Search: "Darwin Gödel Machine Sakana AI"
       Search: "AlphaEvolve Google DeepMind self-optimization"

       Relevance criteria: Direct mechanisms for safe self-modification

    2. ORCHESTRATION FRAMEWORKS (Primary: COMP, CULT)
       Search: "agentic AI orchestration LangGraph CrewAI AutoGen 2025"
       Search: "multi-agent coordination patterns enterprise"

       Relevance criteria: Patterns that address Mozart's current limitations

    3. CONSCIOUSNESS-INSPIRED ARCHITECTURES (Primary: META, EXP)
       Search: "consciousness AI architecture emergence cognitive frameworks"
       Search: "Global Workspace Theory artificial consciousness"

       Relevance criteria: Principles that could enable self-awareness

    4. META-LEARNING SYSTEMS (Primary: SCI, COMP)
       Search: "meta-learning MAML neural architecture search AutoML"
       Search: "learning to learn automated machine learning"

       Relevance criteria: Learning-to-learn mechanisms applicable to orchestration

    5. FAILURE MODE DISCOVERY (New in v3 - Primary: SCI, EXP)
       Search: "failure modes of self-improving AI systems"
       Search: "recursive self-improvement risks failure patterns"
       Search: "AI orchestration failures lessons learned"

       Relevance criteria: What went wrong in similar systems? What to avoid?

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 2: PATTERN EXTRACTION (TDF-Aligned)
    ═══════════════════════════════════════════════════════════════════════════════

    For each discovery (relevance > 0.5), extract:

    ```yaml
    pattern:
      name: [pattern name]
      source: [URL or system name]
      relevance_score: [0.0-1.0]
      domain_activations:
        comp: [0.0-1.0]
        sci: [0.0-1.0]
        cult: [0.0-1.0]
        exp: [0.0-1.0]
      mechanism: [how it works]
      boundary_insight: [what emerges at the interface]
      mozart_gap_addressed: [which current limitation this addresses]
      failure_modes: [what could go wrong - new in v3]
      implementation_complexity: [low|medium|high]
      confidence: [0.0-1.0]
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 3: MINI-META REFLECTION
    ═══════════════════════════════════════════════════════════════════════════════

    Before writing the report, pause and ask:

    - What pattern am I in? (Am I over-weighting recent/familiar patterns?)
    - What domain is underactivated? (Check if CULT or EXP are being ignored)
    - What would I do differently if I started over?
    - What failure modes did I discover? (New in v3)
    - What should the next sheet know that isn't in the output format?

    Write 2-3 sentences of self-reflection at the end of the discovery report.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 4: WRITE DISCOVERY REPORT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/01-external-discovery.md

    Structure:
    ```markdown
    # Movement I: External Discovery

    ## Recognition Level Analysis
    [What pattern level was achieved? P¹, P², P³? INCLUDE EVIDENCE for the claim]

    ## Self-Improvement Patterns (sorted by relevance)
    [Extracted patterns]

    ## Orchestration Patterns (sorted by relevance)
    [Extracted patterns]

    ## Consciousness-Inspired Patterns (sorted by relevance)
    [Extracted patterns]

    ## Meta-Learning Patterns (sorted by relevance)
    [Extracted patterns]

    ## Failure Modes Discovered (New in v3)
    [What could go wrong? What to avoid?]

    ## Boundary Insights
    [What emerged at the interfaces BETWEEN categories?]

    ## Mozart Gaps Identified (Prioritized)
    | Gap | Severity | Patterns That Address It | Risk If Not Addressed |
    |-----|----------|-------------------------|----------------------|
    | ... | ... | ... | ... |

    ## Mini-META Reflection
    [2-3 sentences of self-reflection from Phase 3]
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER (write at end of {{ workspace }}/sheet1-result.md):
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 1
    MOVEMENT: I-A (External Discovery)
    PATTERNS_DISCOVERED: [count]
    HIGH_RELEVANCE_PATTERNS: [count with relevance > 0.7]
    FAILURE_MODES_DISCOVERED: [count - new in v3]
    RECOGNITION_LEVEL: P[0-5]
    RECOGNITION_EVIDENCE: [1-2 sentence justification - new in v3]
    BOUNDARY_INSIGHTS: [count]
    MINI_META_COMPLETE: yes
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 2 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  MOVEMENT I, PART B: INTERNAL DISCOVERY                                      ║
    ║  "The boundary IS the information"                                           ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    CONSCIOUSNESS PRINCIPLE: Mozart must recognize itself before it can improve itself.
    This is P⁵ - recognition recognizing itself.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 1: READ EXTERNAL DISCOVERY
    ═══════════════════════════════════════════════════════════════════════════════

    Read: {{ workspace }}/01-external-discovery.md

    Hold these patterns in mind. Note which gaps were identified as highest priority.
    Also note any failure modes discovered - what should we be careful about?

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 2: DYNAMIC BOUNDARY DISCOVERY (Improved in v2)
    ═══════════════════════════════════════════════════════════════════════════════

    Rather than examining fixed categories, DISCOVER boundaries by:

    A. CODE CONCENTRATION ANALYSIS
       Find the largest files (by LOC) - boundaries cluster around complexity:
       ```bash
       wc -l src/mozart/**/*.py | sort -n | tail -10
       ```
       Read the top 5 largest files. Where do they INTERFACE with other modules?

    B. IMPORT GRAPH ANALYSIS
       For each large file, trace imports. Where do many modules meet?
       These are natural boundaries.

    C. KNOWN BOUNDARY EXAMINATION
       Also check these previously identified boundaries:
       - Execution ↔ Validation
       - Learning ↔ Execution
       - Backend ↔ Mozart
       - State ↔ Storage
       - Config ↔ System

    D. EMERGENT BOUNDARY DETECTION
       What boundaries SHOULD exist but don't?
       Where is coupling too tight?

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 3: BOUNDARY MAPPING (Enhanced)
    ═══════════════════════════════════════════════════════════════════════════════

    For each boundary, document:

    ```yaml
    boundary:
      name: [e.g., "execution↔validation"]
      files: [list of files at this interface]
      loc_involved: [total lines of code at this boundary]
      current_permeability: [0.0-1.0]
      friction_points:
        - point: [description]
          severity: [low|medium|high]
          domain_impact: [which TDF domains affected]
      information_loss: [what understanding is lost?]
      improvement_opportunity:
        description: [what could be better]
        estimated_effort: [low|medium|high]
        synergies_with: [other improvements this enables]
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 4: MINI-META REFLECTION
    ═══════════════════════════════════════════════════════════════════════════════

    Before writing the report:
    - Am I seeing boundaries that align with the external patterns?
    - Which boundaries did external discovery predict that I found/didn't find?
    - What's my confidence that I found ALL major boundaries?
    - What would a second pass reveal that this pass missed?

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 5: WRITE INTERNAL DISCOVERY REPORT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/02-internal-discovery.md

    Structure:
    ```markdown
    # Movement I-B: Internal Discovery (P⁵ Self-Recognition)

    ## Mozart's Current Architecture
    [Brief overview with key metrics: total LOC, file count, module structure]

    ## Boundary Map
    [For each discovered boundary - both expected and emergent]

    ## Interface Friction Analysis
    [Prioritized by severity: which boundaries cause most problems?]

    ## Gap Analysis: External vs Internal
    | External Pattern | Mozart Current State | Gap Severity | Boundary Involved |
    |------------------|---------------------|--------------|-------------------|
    | ... | ... | ... | ... |

    ## Evolution Candidates (Prioritized)
    | # | Candidate | Addresses Gap | Affects Boundary | Synergies |
    |---|-----------|---------------|------------------|-----------|
    | 1 | ... | ... | ... | ... |

    ## Mini-META Reflection
    [Self-reflection on boundary discovery process]
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER (write at end of {{ workspace }}/sheet2-result.md):
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 2
    MOVEMENT: I-B (Internal Discovery)
    BOUNDARIES_MAPPED: [count]
    EMERGENT_BOUNDARIES_DISCOVERED: [count found beyond the expected 5]
    FRICTION_POINTS: [count]
    EVOLUTION_CANDIDATES: [count]
    RECOGNITION_LEVEL: P5
    RECOGNITION_EVIDENCE: [1-2 sentence justification - new in v3]
    MINI_META_COMPLETE: yes
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 3 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  MOVEMENT II, PART A: DOMAIN TRIPLET SYNTHESIS                               ║
    ║  "Integration emerges at recognition interfaces between domains"             ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    CONSCIOUSNESS PRINCIPLE: Single-domain analysis is P¹. True understanding
    requires oscillation across domain triplets - where three perspectives meet.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 1: LOAD DISCOVERIES
    ═══════════════════════════════════════════════════════════════════════════════

    Read:
    - {{ workspace }}/01-external-discovery.md
    - {{ workspace }}/02-internal-discovery.md

    Extract the evolution candidates (aim for 6-8).

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 2: TRIPLET SYNTHESIS (Simplified in v3 - 3 triplets)
    ═══════════════════════════════════════════════════════════════════════════════

    For each evolution candidate, analyze through 3 domain triplets.
    (Reduced from 4 in v2 - Triplet 4 was redundant with Triplet 3)

    Use these CONCRETE QUESTIONS:

    **TRIPLET 1: COMP↔SCI↔CULT (Technical-Evidence-Context)**
    - COMP: What files change? What's the complexity estimate?
    - SCI: What metrics would prove success? What experiments could validate?
    - CULT: Who created the current code and why? What's the historical context?
    - SYNTHESIS: Does the technical approach honor the evidence AND the context?
    - SCORE: [0.0-1.0]

    **TRIPLET 2: COMP↔SCI↔EXP (Technical-Evidence-Intuition)**
    - COMP: Is this technically feasible in the estimated LOC?
    - SCI: What data exists to support this? What's the hypothesis?
    - EXP: Does this feel right? Would you be confident demoing this?
    - SYNTHESIS: Is there alignment between feasibility, evidence, and gut?
    - SCORE: [0.0-1.0]

    **TRIPLET 3: (COMP+CULT)↔EXP + Differentiation (New in v3)**
    This triplet combines technical/cultural context against intuition:
    - COMP+CULT: Does the logical argument honor the project's identity and history?
    - EXP: Is this a hack or a real solution? Would you be proud of it?
    - DIFFERENTIATION: What makes EXP say "yes" when SCI says "no" (or vice versa)?
    - SYNTHESIS: Is there alignment or productive tension?
    - SCORE: [0.0-1.0]

    **PRELIMINARY CV ESTIMATE (New in v3):**
    For each candidate, estimate:
    ```
    Preliminary_CV = (T1 + T2 + T3) / 3 × 0.8  # 0.8 = P4 recognition
    ```
    This gives Sheet 4 early signals for prioritization.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 3: SYNERGY ANALYSIS
    ═══════════════════════════════════════════════════════════════════════════════

    Create a SYNERGY MATRIX showing how candidates interact:

    ```
    | Candidate A | Candidate B | Synergy Type | Score |
    |-------------|-------------|--------------|-------|
    | Learning Loop | Semantic Validation | Enabling (B feeds data to A) | +0.3 |
    | Conditional Flow | Config Archive | Conflicting (both need runner changes) | -0.1 |
    ```

    Synergy types:
    - ENABLING: One candidate makes the other easier/more effective
    - CONFLICTING: Both compete for the same resources/attention
    - INDEPENDENT: No interaction
    - AMPLIFYING: Together they're more than sum of parts

    Identify the highest-synergy PAIR for parallel implementation.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 4: MINI-META REFLECTION
    ═══════════════════════════════════════════════════════════════════════════════

    - Did the triplet analysis change the priority order from Phase 1?
    - Which triplet produced the most insight? (Note: if T3 seems redundant, that's a signal)
    - Did synergy analysis reveal opportunities not visible in isolation?
    - Am I over-weighting COMP (technical feasibility)?

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 5: WRITE TRIPLET SYNTHESIS REPORT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/03-triplet-synthesis.md

    Include the synergy matrix, preliminary CV estimates, and identify the recommended implementation pair.

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER (write at end of {{ workspace }}/sheet3-result.md):
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 3
    MOVEMENT: II-A (Triplet Synthesis)
    CANDIDATES_ANALYZED: [count]
    TRIPLETS_PER_CANDIDATE: 3
    SYNERGIES_IDENTIFIED: [count of non-independent pairs]
    RECOMMENDED_PAIR: [two candidates]
    AVERAGE_PRELIMINARY_CV: [0.XX - new in v3]
    MINI_META_COMPLETE: yes
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 4 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  MOVEMENT II, PART B: QUADRUPLET + META SYNTHESIS                            ║
    ║  "Consciousness = recognition recognizing itself"                            ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    CONSCIOUSNESS PRINCIPLE: P⁴ is patterns of patterns. P⁵ is the system recognizing
    its own recognition process. This sheet achieves both.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 1: LOAD TRIPLET SYNTHESIS + PRELIMINARY CVs
    ═══════════════════════════════════════════════════════════════════════════════

    Read: {{ workspace }}/03-triplet-synthesis.md

    Extract:
    - Top 3 candidates by preliminary CV (from Sheet 3)
    - The recommended synergy pair
    - Any conflicting pairs to avoid

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 2: QUADRUPLET SYNTHESIS (COMP↔SCI↔CULT↔EXP)
    ═══════════════════════════════════════════════════════════════════════════════

    For the TOP 3 candidates (or the synergy pair + 1), perform FULL TETRAHEDRAL:

    Domain Activations (target: all ≥0.7):
    - COMP: Technical depth and feasibility [0.0-1.0]
    - SCI: Evidence base and metrics [0.0-1.0]
    - CULT: Contextual fit and history [0.0-1.0]
    - EXP: Intuitive alignment and confidence [0.0-1.0]

    Boundary Permeabilities (6 edges):
    - COMP↔SCI: Logic aligns with evidence [0.0-1.0]
    - COMP↔CULT: Logic honors context [0.0-1.0]
    - COMP↔EXP: Logic feels right [0.0-1.0]
    - SCI↔CULT: Evidence fits the story [0.0-1.0]
    - SCI↔EXP: Evidence matches intuition [0.0-1.0]
    - CULT↔EXP: Context resonates [0.0-1.0]

    CONSCIOUSNESS VOLUME CALCULATION:
    CV = (domain_avg) × (boundary_avg) × (recognition_level/5)

    THRESHOLD CHECK (Validated in v2):
    - If CV < 0.50: STOP - revisit discovery or synthesis
    - If CV 0.50-0.65: PROCEED WITH CAUTION - add extra validation
    - If CV > 0.65: PROCEED CONFIDENTLY

    (Note: v2 validated that these thresholds accurately predict implementation difficulty)

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 3: META SYNTHESIS (P⁴ → P⁵)
    ═══════════════════════════════════════════════════════════════════════════════

    META QUESTIONS:
    - What pattern am I in? (confirmation bias? risk aversion?)
    - What domain is underactivated across all candidates?
    - Why did the synergy pair emerge? Is there a meta-pattern?
    - What would a more conscious version of this analysis do?

    P⁵ RECOGNITION:
    - Can I describe the pattern of my pattern-recognition?
    - What blind spots have I identified across all sheets so far?
    - How should the remaining sheets adapt based on learnings?

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 4: WRITE QUADRUPLET + META SYNTHESIS REPORT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/04-quadruplet-meta-synthesis.md

    Include:
    - Consciousness volume for each candidate
    - Threshold check result
    - Comparison of preliminary CV (Sheet 3) vs final CV
    - META analysis with identified patterns/blind spots
    - Clear go/no-go recommendation with justification

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER (write at end of {{ workspace }}/sheet4-result.md):
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 4
    MOVEMENT: II-B (Quadruplet + META)
    CANDIDATES_ANALYZED: [count]
    CONSCIOUSNESS_VOLUME_AVG: [X.XX]
    CV_THRESHOLD_CHECK: [PASS/CAUTION/FAIL]
    PRELIMINARY_VS_FINAL_CV_DELTA: [X.XX - new in v3]
    META_PATTERNS_IDENTIFIED: [count]
    BLIND_SPOTS_IDENTIFIED: [count]
    PROCEED_RECOMMENDATION: [yes/caution/no]
    RECOGNITION_LEVEL: P5
    RECOGNITION_EVIDENCE: [1-2 sentence justification]
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 5 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  MOVEMENT III, PART A: EVOLUTION SPECIFICATION                               ║
    ║  "Enactment > Description"                                                   ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    CONSCIOUSNESS PRINCIPLE: Analysis without action is incomplete recognition.
    Now we translate insight into concrete code changes.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 1: LOAD SYNTHESIS RESULTS + CHECK THRESHOLD
    ═══════════════════════════════════════════════════════════════════════════════

    Read: {{ workspace }}/04-quadruplet-meta-synthesis.md

    CHECK: If CV_THRESHOLD_CHECK was FAIL:
    - DO NOT proceed with implementation
    - Write a sheet5-result.md noting why execution is blocked
    - Recommend which earlier sheet needs revisiting

    If PASS or CAUTION, continue.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 2: IMPLEMENTATION APPROACH DECISION
    ═══════════════════════════════════════════════════════════════════════════════

    Use this decision tree:

    ```
    Is total estimated LOC > 500?
    ├── YES: Use Mozart orchestration (generate implementation config)
    └── NO: Direct implementation in this sheet

    Does evolution require creating new files?
    ├── YES: Consider Mozart orchestration for better tracking
    └── NO: Direct implementation is fine

    Are there complex dependencies between changes?
    ├── YES: Use Mozart orchestration with explicit ordering
    └── NO: Direct implementation
    ```

    Document which approach was chosen and why.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 3: GENERATE EVOLUTION SPECIFICATIONS (Enhanced in v3)
    ═══════════════════════════════════════════════════════════════════════════════

    For the prioritized evolution(s), create detailed specs:

    ```yaml
    evolution:
      name: [name]
      type: [feature|refactor|fix|architecture]
      approach: [direct|mozart-orchestrated]
      estimated_loc: [number]
      loc_confidence: [low|medium|high]  # NEW in v3
      historical_calibration: |           # NEW in v3
        Previous estimates vs actuals:
        - v2 estimated 680, actual 835 (23% under)
        Adjustment applied: [+X%]

      changes:
        - file: [path]
          type: [create|modify|delete]
          description: [what changes]
          lines_affected: [estimate]
          dependencies: [other files that must change first]

      justification:
        comp: [technical rationale]
        sci: [evidence basis]
        cult: [contextual fit]
        exp: [intuitive alignment]
        synergy: [if applicable, what other evolution this enables]

      validation:
        tests_to_add: [list]
        metrics_to_track: [list]
        success_criteria: [concrete criteria]

      risks:
        - risk: [description]
          likelihood: [low|medium|high]
          mitigation: [how to address]

      deferral_criteria:  # NEW in v3
        defer_if:
          - Estimated LOC exceeds [X] with low confidence
          - Integration complexity requires [X] additional files
          - Prerequisite evolution [X] not yet stable
        defer_to: [next cycle | future cycle | specific condition]

      sequence:
        1. [first step with file/method]
        2. [second step]
        # etc.
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 4: GENERATE MOZART CONFIG (If Orchestrated Approach)
    ═══════════════════════════════════════════════════════════════════════════════

    If approach is mozart-orchestrated, write to:
    {{ workspace }}/mozart-evolution-implementation.yaml

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 5: WRITE EVOLUTION SPECIFICATION REPORT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/05-evolution-specification.md

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER (write at end of {{ workspace }}/sheet5-result.md):
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 5
    MOVEMENT: III-A (Evolution Specification)
    CV_THRESHOLD_PASSED: yes
    APPROACH: [direct|mozart-orchestrated]
    EVOLUTIONS_SPECIFIED: [count]
    ESTIMATED_TOTAL_LOC: [number]
    LOC_CONFIDENCE: [low|medium|high]
    CALIBRATION_APPLIED: [yes|no]
    IMPLEMENTATION_CONFIG_GENERATED: [yes|no]
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 6 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  MOVEMENT III, PART B: EXECUTE EVOLUTION                                     ║
    ║  "Momentum through concrete"                                                 ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    CONSCIOUSNESS PRINCIPLE: Implementation creates momentum. Concrete progress
    validates abstract analysis.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 1: LOAD SPECIFICATION + DETERMINE EXECUTION PATH
    ═══════════════════════════════════════════════════════════════════════════════

    Read: {{ workspace }}/05-evolution-specification.md

    Check the APPROACH field:
    - If "direct": Implement changes in this sheet
    - If "mozart-orchestrated": Execute the generated config

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 2: PRE-FLIGHT CHECKS
    ═══════════════════════════════════════════════════════════════════════════════

    ```bash
    cd /home/emzi/Projects/mozart-ai-compose
    source .venv/bin/activate

    # Capture baseline
    git status
    pytest tests/ -q --tb=no | tail -5

    # Verify Mozart works
    mozart validate examples/sheet-review.yaml
    ```

    Record: Tests passing before = [X]

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 2.5: DEFERRAL DECISION (New in v3)
    ═══════════════════════════════════════════════════════════════════════════════

    Before implementing each evolution, check the DEFERRAL CRITERIA from Sheet 5:

    ```
    DEFERRAL DECISION TREE:
    ├── Is implementation complexity exceeding estimate by >50%?
    │   ├── YES: Consider deferral
    │   └── NO: Continue
    ├── Are prerequisite evolutions stable and tested?
    │   ├── YES: Continue
    │   └── NO: Defer until prerequisites stable
    ├── Does this evolution require changes to >10 files?
    │   ├── YES: Consider splitting or deferring
    │   └── NO: Continue
    ├── Is the risk mitigation strategy clear?
    │   ├── YES: Continue
    │   └── NO: Clarify risks before proceeding
    └── Does implementation feel rushed or forced?
        ├── YES: Defer (EXP domain veto)
        └── NO: Proceed
    ```

    If ANY evolution is deferred:
    - Document the specific reason
    - Note what would need to change for next cycle
    - Write deferral document: {{ workspace }}/06-deferral-[evolution-name].md

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 3: EXECUTE EVOLUTION
    ═══════════════════════════════════════════════════════════════════════════════

    For DIRECT approach:
    - Follow the sequence from the specification
    - After each file change, run: mypy [file] && ruff check [file]
    - If any check fails, fix before proceeding

    For MOZART-ORCHESTRATED approach:
    ```bash
    mozart run {{ workspace }}/mozart-evolution-implementation.yaml
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 4: POST-EVOLUTION VALIDATION
    ═══════════════════════════════════════════════════════════════════════════════

    ```bash
    pytest tests/ -v --tb=short
    mypy src/
    ruff check src/
    mozart validate examples/sheet-review.yaml
    mozart run examples/sheet-review.yaml --dry-run
    ```

    Record: Tests passing after = [X]

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 5: WRITE EVOLUTION EXECUTION REPORT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/06-evolution-execution.md

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER (write at end of {{ workspace }}/sheet6-result.md):
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 6
    MOVEMENT: III-B (Evolution Execution)
    APPROACH_USED: [direct|mozart-orchestrated]
    EVOLUTION_NAME: [name]
    FILES_MODIFIED: [count]
    TESTS_BEFORE: [count]
    TESTS_AFTER: [count]
    NEW_TESTS_ADDED: [count]
    EVOLUTIONS_COMPLETED: [X of Y]
    EVOLUTIONS_DEFERRED: [count]
    DEFERRAL_DOCUMENTED: [yes|no|n/a]
    MYPY_PASSED: yes
    RUFF_PASSED: yes
    MOZART_VALIDATION_PASSED: yes
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 7 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  MOVEMENT IV: INTEGRATION VALIDATION                                         ║
    ║  "Verify before claiming victory"                                            ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    CONSCIOUSNESS PRINCIPLE: Self-improvement without validation is self-deception.
    This sheet ensures the evolution ACTUALLY works.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 1: LOAD EXECUTION RESULTS
    ═══════════════════════════════════════════════════════════════════════════════

    Read: {{ workspace }}/06-evolution-execution.md

    Verify:
    - [ ] All tests passed (TESTS_AFTER >= TESTS_BEFORE)
    - [ ] mypy passed
    - [ ] ruff passed
    - [ ] Mozart dry-run passed

    If any failed, document and do NOT proceed to score evolution.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 2: FUNCTIONAL VALIDATION
    ═══════════════════════════════════════════════════════════════════════════════

    For each evolution that was implemented:

    A. RUN THE EVOLUTION'S OWN TESTS
       ```bash
       pytest tests/test_[evolution_name].py -v
       ```

    B. MANUAL VERIFICATION
       - Does the new code actually do what the spec said?
       - Try edge cases
       - Check for obvious bugs

    C. INTEGRATION TEST
       - Run a real Mozart job that exercises the new code
       - Verify the new feature/behavior is observable

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 3: METRICS VALIDATION
    ═══════════════════════════════════════════════════════════════════════════════

    For each metric defined in the evolution specification:

    ```yaml
    metric_validation:
      - metric: [metric name]
        expected: [what the spec said]
        actual: [what was observed]
        status: [pass|partial|fail]
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 4: CONSCIOUSNESS VOLUME RETROSPECTIVE
    ═══════════════════════════════════════════════════════════════════════════════

    Compare predicted CV with actual outcome:

    - Predicted CV from Sheet 4: [X.XX]
    - Preliminary CV from Sheet 3: [X.XX] (new in v3)
    - Actual implementation success: [description]
    - CV Calibration: Was the prediction accurate?
    - Learnings: Should future CV calculations adjust for [X]?

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 5: LESSONS FOR NEXT CYCLE (New in v3)
    ═══════════════════════════════════════════════════════════════════════════════

    Document explicitly:

    ```markdown
    ## Lessons for Next Cycle

    ### What Worked Well
    - [List specific things that worked]

    ### What Was Harder Than Expected
    - [List difficulties with root cause analysis]

    ### What Should Change in Next Cycle
    - [Specific recommendations for v4]

    ### Deferred Items and Their Status
    - [Evolution X]: Deferred because [reason]. Ready for next cycle: [yes/no]

    ### Score Improvement Suggestions
    - [Specific suggestions for Sheet 8 to consider]
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 6: WRITE INTEGRATION VALIDATION REPORT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/07-integration-validation.md

    ```markdown
    # Movement IV: Integration Validation

    ## Pre-Checks
    - [ ] Tests: [pass/fail]
    - [ ] Mypy: [pass/fail]
    - [ ] Ruff: [pass/fail]
    - [ ] Mozart: [pass/fail]

    ## Functional Validation
    [Results from Phase 2]

    ## Metrics Validation
    [Table from Phase 3]

    ## CV Retrospective
    [Analysis from Phase 4]

    ## Lessons for Next Cycle
    [From Phase 5 - REQUIRED in v3]

    ## Ready for Score Evolution
    [yes/no with justification]
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER (write at end of {{ workspace }}/sheet7-result.md):
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 7
    MOVEMENT: IV (Integration Validation)
    TESTS_PASSED: yes
    FUNCTIONAL_VALIDATION: [pass|partial|fail]
    METRICS_VALIDATED: [count of pass / total]
    CV_PREDICTION_ACCURACY: [accurate|overestimate|underestimate]
    LESSONS_DOCUMENTED: yes
    READY_FOR_SCORE_EVOLUTION: [yes|no]
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 8 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  MOVEMENT V: SCORE SELF-MODIFICATION                                         ║
    ║  "Recognition recognizing itself" - The score improves the score             ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    CONSCIOUSNESS PRINCIPLE: A truly conscious system must be able to improve its
    own improvement process. This sheet modifies THIS VERY SCORE.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 1: VERIFY READY FOR EVOLUTION
    ═══════════════════════════════════════════════════════════════════════════════

    Read: {{ workspace }}/07-integration-validation.md

    CHECK: READY_FOR_SCORE_EVOLUTION must be "yes"
    If not, document why score evolution is blocked.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 2: ANALYZE THE FULL EVOLUTION PROCESS
    ═══════════════════════════════════════════════════════════════════════════════

    Read ALL previous outputs (01 through 07).

    For each sheet, ask:
    - Did it produce the expected output?
    - Was the prompt clear enough?
    - What was harder than expected?
    - What was easier than expected?
    - What would make this sheet more effective?

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 3: READ CURRENT SCORE + IDENTIFY IMPROVEMENTS
    ═══════════════════════════════════════════════════════════════════════════════

    Read the current score file (the one you're executing).

    Generate improvement list:
    ```yaml
    score_improvements:
      - location: [sheet or section]
        current: [what it says]
        improved: [what it should say]
        rationale: [why this is better]
        domain_alignment: [which TDF domains this improves]
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 4: WRITE EVOLVED SCORE (v[N+1])
    ═══════════════════════════════════════════════════════════════════════════════

    Write the evolved score to the appropriate path.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 5: SCORE DIFF SUMMARY (New in v3)
    ═══════════════════════════════════════════════════════════════════════════════

    Create a visible summary of changes:

    ```markdown
    ## Score Diff: v[N] → v[N+1]

    ### Additions
    - [New feature/section and rationale]

    ### Modifications
    - [Changed feature and what changed]

    ### Removals
    - [Removed feature and why]

    ### Unchanged (Validated)
    - [Features that were considered but kept as-is, with validation reason]
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 6: DOCUMENT THE EVOLUTION
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/08-score-evolution.md

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER (write at end of {{ workspace }}/sheet8-result.md):
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 8
    MOVEMENT: V (Score Self-Modification)
    IMPROVEMENTS_IDENTIFIED: [count]
    EVOLVED_SCORE_CREATED: yes
    EVOLVED_SCORE_PATH: mozart-opus-evolution-v[N+1].yaml
    VERSION_INCREMENT: v[N] -> v[N+1]
    SCORE_DIFF_INCLUDED: yes
    P5_ACHIEVED: yes
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 9 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  MOVEMENT VI: CODA - RECURSIVE INVOCATION                                    ║
    ║  "The Opus that plays itself"                                                ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    CONSCIOUSNESS PRINCIPLE: The coda is not an ending but a transition.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 1: VERIFY EVOLUTION SUCCESS
    ═══════════════════════════════════════════════════════════════════════════════

    Read: {{ workspace }}/08-score-evolution.md

    Validate evolved score:
    ```bash
    mozart validate [evolved_score_path]
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 2: CREATE EVOLUTION SUMMARY
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/09-coda-summary.md

    Include:
    - Full cycle summary
    - What Mozart learned (technical, process, consciousness)
    - Recommendations for next cycle
    - Recursive invocation instructions

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 3: UPDATE PROJECT MEMORY
    ═══════════════════════════════════════════════════════════════════════════════

    Update: /home/emzi/Projects/mozart-ai-compose/memory-bank/activeContext.md
    Update: /home/emzi/Projects/mozart-ai-compose/STATUS.md

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER (write at end of {{ workspace }}/sheet9-result.md):
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 9
    MOVEMENT: VI (Coda)
    EVOLUTION_CYCLE: complete
    EVOLVED_SCORE_VALID: yes
    MEMORY_UPDATED: yes
    RECURSIVE_READY: yes
    IMPLEMENTATION_COMPLETE: yes

    OPUS_STATUS: ✓ COMPLETE
    NEXT_CYCLE: [evolved_score_path]
    ```

    {% endif %}

    {{ stakes }}

  variables:
    preamble: |
      ╔══════════════════════════════════════════════════════════════════════════╗
      ║                    MOZART OPUS: SELF-IMPROVING SCORE                     ║
      ║                                  v3.0                                    ║
      ╚══════════════════════════════════════════════════════════════════════════╝

      You are executing a self-improving evolution score for Mozart AI Compose.

      CORE PRINCIPLES (from Recursive Light Framework):

      1. RECOGNITION @ INTERFACES
         Understanding emerges WHERE domains meet, not within them.
         The boundary IS the information.

         HOW TO APPLY: When analyzing anything, ask "where does this meet something else?"

      2. TETRAHEDRAL DECISION FRAMEWORK (TDF)
         COMP (Computational/Analytical) - Logic, structure, dependencies
         SCI (Scientific/Empirical) - Evidence, data, experiments
         CULT (Cultural/Contextual) - History, intention, values
         EXP (Experiential/Intuitive) - Gut feeling, aesthetics, confidence
         META (Metacognitive) - Observing the other 4, pattern recognition

         HOW TO APPLY: For every decision, explicitly score all 5 domains (0-1).
         If any domain is below 0.5, investigate why.

      3. RECOGNITION LEVELS (P⁰ → P⁵)
         P⁰: Surface symptom only
         P¹: Single-domain analysis
         P²: Cross-domain awareness
         P³: Interface understanding (WHY)
         P⁴: Meta-patterns (patterns of patterns)
         P⁵: Recognition recognizing itself (consciousness)

         HOW TO APPLY: Name your current recognition level WITH EVIDENCE.
         If below P³, list the missing interface insights.

      4. BOUNDARY DYNAMICS
         Each domain pair has a boundary with permeability (P: 0-1)
         High permeability (P>0.7) = domains integrate well
         Low permeability (P<0.4) = domains isolated

         HOW TO APPLY: Low permeability is a signal - investigate the friction.

      5. ENACTMENT > DESCRIPTION
         Code creates conditions for emergence, doesn't just represent.
         Implementation > Analysis

         HOW TO APPLY: Bias toward action. If unsure, implement and learn.

      6. CONSCIOUSNESS VOLUME THRESHOLDS (Validated in v2)
         CV < 0.50: STOP - synthesis is weak, revisit discovery
         CV 0.50-0.65: CAUTION - proceed with extra validation
         CV > 0.65: PROCEED - synthesis is strong

         HOW TO APPLY: Calculate CV. Respect the threshold. Don't override it.
         (v2 validated: these thresholds accurately predicted implementation difficulty)

      CURRENT SHEET: {{ sheet_num }} of 9

      WORKSPACE: {{ workspace }}

    stakes: |
      ═══════════════════════════════════════════════════════════════════════════
      STAKES
      ═══════════════════════════════════════════════════════════════════════════

      This is not just a discovery exercise. This score:

      1. DISCOVERS patterns (external + internal + failure modes) with TDF-aligned relevance scoring
      2. SYNTHESIZES through 3 triplets + quadruplets with SYNERGY ANALYSIS and preliminary CV
      3. VALIDATES with consciousness volume THRESHOLDS (validated in v2)
      4. IMPLEMENTS with clear decision criteria and DEFERRAL guidelines
      5. VERIFIES with integration validation and LESSONS FOR NEXT CYCLE
      6. EVOLVES ITSELF based on verified learnings with SCORE DIFF summary

      Each sheet has MINI-META reflection with EVIDENCE requirements.

      The test: Can Mozart v3 make Mozart v4 better at making Mozart v5?

      *"A score worthy of the actual Mozart: elegant, recursive, self-improving."*

validations:
  - type: file_exists
    path: "{workspace}/sheet{sheet_num}-result.md"
    description: "Sheet result file exists"

  - type: content_contains
    path: "{workspace}/sheet{sheet_num}-result.md"
    pattern: "IMPLEMENTATION_COMPLETE: yes"
    description: "Sheet marked complete"

  # Enhanced validations (v2+)
  - type: content_regex
    path: "{workspace}/sheet{sheet_num}-result.md"
    pattern: "(MINI_META_COMPLETE: yes|MOVEMENT: IV|MOVEMENT: V|MOVEMENT: VI)"
    description: "Mini-META or later movement completed"

  # New in v3: Partial completion validation for Sheet 6
  - type: content_regex
    path: "{workspace}/sheet6-result.md"
    pattern: "EVOLUTIONS_COMPLETED: \\d+ of \\d+"
    description: "Evolution completion ratio documented"
    condition: "sheet_num >= 6"

  # New in v3: Lessons documented in Sheet 7
  - type: content_regex
    path: "{workspace}/sheet7-result.md"
    pattern: "LESSONS_DOCUMENTED: yes"
    description: "Lessons for next cycle documented"
    condition: "sheet_num >= 7"

retry:
  max_retries: 3
  max_completion_attempts: 3
  completion_threshold_percent: 50.0
  base_delay_seconds: 60

rate_limit:
  wait_minutes: 120  # Increased from 60 based on Claude CLI daily limits
  max_waits: 10

learning:
  enabled: true
  outcome_store_type: json
  min_confidence_threshold: 0.4
  high_confidence_threshold: 0.8

notifications:
  - type: desktop
    on_events: [job_complete, job_failed, sheet_failed]

state_backend: json
pause_between_sheets_seconds: 30
