# ╔══════════════════════════════════════════════════════════════════════════════╗
# ║                    PHASE D1: MODULARIZE errors.py                            ║
# ║                                                                              ║
# ║  Split src/mozart/core/errors.py (2388 LOC) into focused modules             ║
# ║  Maintain backward compatibility via __init__.py re-exports                  ║
# ╚══════════════════════════════════════════════════════════════════════════════╝

name: "modularization-d1-errors"
description: "Split errors.py into focused modules with backward compatibility"

workspace: "/home/emzi/Projects/mozart-ai-compose/modularization-workspace"

backend:
  type: claude_cli
  skip_permissions: true
  working_directory: "/home/emzi/Projects/mozart-ai-compose"
  timeout_seconds: 3600

cross_sheet:
  auto_capture_stdout: true
  max_output_chars: 2000
  lookback_sheets: 1

sheet:
  size: 1
  total_items: 6
  start_item: 1

retry:
  max_retries: 2

prompt:
  template: |
    {{ preamble }}

    {% if sheet_num == 1 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  SHEET 1: CREATE codes.py - Enums and Constants                              ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    **Task:** Extract enums and constants from errors.py into codes.py

    **Source file:** src/mozart/core/errors.py

    **Extract these to src/mozart/core/errors_staging/codes.py:**
    - `ExitReason` type alias (line ~40)
    - `RetryDelays` class (lines ~48-79)
    - `Severity` enum (lines ~87-104)
    - `ErrorCode` enum (lines ~218-660) - This is large, include ALL of it
    - `ErrorCategory` enum (lines ~660-687)

    **Instructions:**
    1. Create STAGING directory: `mkdir -p src/mozart/core/errors_staging`
       **CRITICAL: Use errors_staging NOT errors - to avoid shadowing the original module**
    2. Create `src/mozart/core/errors_staging/codes.py` with proper imports
    3. Include docstring explaining the module purpose
    4. Keep ALL original code, including docstrings and comments
    5. Ensure imports are minimal (only what's needed)

    **Expected structure:**
    ```python
    """Error codes, categories, and severity levels.

    Contains the structured error classification enums used throughout Mozart.
    """
    from __future__ import annotations
    from enum import Enum, IntEnum
    from typing import Literal, NamedTuple

    # Type alias
    ExitReason = ...

    # Classes and enums
    class RetryDelays: ...
    class Severity(IntEnum): ...
    class RetryBehavior(NamedTuple): ...  # Needed by ErrorCode
    class ErrorCode(str, Enum): ...
    class ErrorCategory(str, Enum): ...
    ```

    Write progress to {{ workspace }}/sheet1-codes.md

    {% elif sheet_num == 2 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  SHEET 2: CREATE models.py - Data Classes                                    ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    {% if previous_outputs %}
    Previous: {{ previous_outputs[1][:500] if 1 in previous_outputs else "" }}
    {% endif %}

    **Task:** Extract data models from errors.py into models.py

    **Extract these to src/mozart/core/errors_staging/models.py:**
    - `ParsedCliError` dataclass (lines ~112-150)
    - `ErrorInfo` dataclass (lines ~155-195)
    - `ClassifiedError` dataclass (lines ~724-780)
    - `ErrorChain` dataclass (lines ~782-815)
    - `ClassificationResult` dataclass (lines ~816-915)

    **Instructions:**
    1. Create `src/mozart/core/errors_staging/models.py`
    2. Import ErrorCode, ErrorCategory, Severity from `.codes`
    3. Keep ALL original code, docstrings, methods, properties
    4. Ensure `ClassifiedError.severity` property works (imports Severity)

    Write progress to {{ workspace }}/sheet2-models.md

    {% elif sheet_num == 3 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  SHEET 3: CREATE signals.py - Signal Handling                                ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    {% if previous_outputs %}
    Previous: {{ previous_outputs[2][:500] if 2 in previous_outputs else "" }}
    {% endif %}

    **Task:** Extract signal constants and helpers from errors.py

    **Extract these to src/mozart/core/errors_staging/signals.py:**
    - `RETRIABLE_SIGNALS` constant (line ~692)
    - `FATAL_SIGNALS` constant (line ~699)
    - `get_signal_name()` function (lines ~708-722)

    **Instructions:**
    1. Create `src/mozart/core/errors_staging/signals.py`
    2. Import `signal` module
    3. Keep docstrings and comments

    Write progress to {{ workspace }}/sheet3-signals.md

    {% elif sheet_num == 4 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  SHEET 4: CREATE parsers.py - JSON Parsing Functions                         ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    {% if previous_outputs %}
    Previous: {{ previous_outputs[3][:500] if 3 in previous_outputs else "" }}
    {% endif %}

    **Task:** Extract parsing functions from errors.py

    **Extract these to src/mozart/core/errors_staging/parsers.py:**
    - `ROOT_CAUSE_PRIORITY` constant (lines ~919-980)
    - `try_parse_json_errors()` function (lines ~984-1030)
    - `_extract_json_errors_from_text()` function (lines ~1034-1115)
    - `classify_single_json_error()` function (lines ~1119-1315)
    - `select_root_cause()` function (lines ~1317-1443)

    **Instructions:**
    1. Create `src/mozart/core/errors_staging/parsers.py`
    2. Import from `.codes`, `.models` as needed
    3. Include logger setup
    4. Keep ALL code including helper functions

    Write progress to {{ workspace }}/sheet4-parsers.md

    {% elif sheet_num == 5 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  SHEET 5: CREATE classifier.py - ErrorClassifier Class                       ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    {% if previous_outputs %}
    Previous: {{ previous_outputs[4][:500] if 4 in previous_outputs else "" }}
    {% endif %}

    **Task:** Extract ErrorClassifier class from errors.py

    **Extract to src/mozart/core/errors_staging/classifier.py:**
    - `_emit_deprecation_warning()` function (lines ~1445-1465)
    - `ErrorClassifier` class (lines ~1466-2388)

    **Instructions:**
    1. Create `src/mozart/core/errors_staging/classifier.py`
    2. Import from `.codes`, `.models`, `.signals`, `.parsers`
    3. This is the largest piece (~950 LOC)
    4. Keep ALL methods, patterns, and docstrings

    Write progress to {{ workspace }}/sheet5-classifier.md

    {% elif sheet_num == 6 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  SHEET 6: ATOMIC SWAP - Staging → Final + VERIFY                             ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    {% if previous_outputs %}
    Previous: {{ previous_outputs[5][:500] if 5 in previous_outputs else "" }}
    {% endif %}

    **Task:** Create __init__.py, then atomically swap staging to final

    **CRITICAL: This sheet performs the atomic swap. Previous sheets created files
    in errors_staging/ to avoid shadowing the original errors.py module.**

    **Step 1: Create __init__.py in STAGING directory**
    Create `src/mozart/core/errors_staging/__init__.py`:
    ```python
    """Error classification and handling.

    Re-exports all public symbols for backward compatibility.
    """
    from mozart.core.errors.codes import (
        ErrorCategory,
        ErrorCode,
        ExitReason,
        RetryBehavior,
        RetryDelays,
        Severity,
    )
    from mozart.core.errors.models import (
        ClassificationResult,
        ClassifiedError,
        ErrorChain,
        ErrorInfo,
        ParsedCliError,
    )
    from mozart.core.errors.signals import (
        FATAL_SIGNALS,
        RETRIABLE_SIGNALS,
        get_signal_name,
    )
    from mozart.core.errors.parsers import (
        ROOT_CAUSE_PRIORITY,
        classify_single_json_error,
        select_root_cause,
        try_parse_json_errors,
    )
    from mozart.core.errors.classifier import ErrorClassifier

    __all__ = [
        "ErrorCategory", "ErrorCode", "ExitReason", "RetryBehavior",
        "RetryDelays", "Severity", "ClassificationResult", "ClassifiedError",
        "ErrorChain", "ErrorInfo", "ParsedCliError", "FATAL_SIGNALS",
        "RETRIABLE_SIGNALS", "get_signal_name", "ROOT_CAUSE_PRIORITY",
        "classify_single_json_error", "select_root_cause",
        "try_parse_json_errors", "ErrorClassifier",
    ]
    ```

    **Step 2: Perform ATOMIC SWAP**
    Execute these commands in order:
    ```bash
    # Backup original
    mv src/mozart/core/errors.py src/mozart/core/errors_legacy.py

    # Swap staging to final (this makes the package active)
    mv src/mozart/core/errors_staging src/mozart/core/errors

    # Clear Python cache to avoid stale imports
    find src/mozart/core -name "__pycache__" -type d -exec rm -rf {} + 2>/dev/null || true
    ```

    **Step 3: Verify imports work**
    ```bash
    python -c "from mozart.core.errors import ErrorCode, ErrorClassifier, ClassifiedError; print('Imports OK')"
    ```

    **Step 4: Run error-related tests**
    ```bash
    pytest tests/ -k "error" --tb=short -q 2>&1 | tail -10
    ```

    **Step 5: Verify Mozart CLI still works**
    ```bash
    mozart --help | head -5
    ```

    Write final status to {{ workspace }}/sheet6-final.md with:
    - Swap status (success/failure)
    - Import verification result
    - Test results summary
    - Any issues encountered

    {% endif %}

  variables:
    preamble: |
      ╔══════════════════════════════════════════════════════════════════════════╗
      ║                MOZART MODULARIZATION: errors.py → errors/                ║
      ║                                                                          ║
      ║  Target: Split 2388 LOC file into focused modules                        ║
      ║  Constraint: Maintain 100% backward compatibility                        ║
      ╚══════════════════════════════════════════════════════════════════════════╝

      **Module Structure (using staging to avoid import conflicts):**
      ```
      Sheets 1-5 create files in:
      src/mozart/core/errors_staging/  <-- STAGING (doesn't shadow errors.py)
      ├── codes.py
      ├── models.py
      ├── signals.py
      ├── parsers.py
      └── classifier.py

      Sheet 6 performs atomic swap:
      1. Create __init__.py in staging
      2. mv errors.py → errors_legacy.py
      3. mv errors_staging/ → errors/

      Final structure:
      src/mozart/core/errors/  <-- Package (now active)
      ├── __init__.py
      ├── codes.py, models.py, signals.py, parsers.py, classifier.py
      ```

      **Rules:**
      1. Sheets 1-5: ALWAYS use errors_staging/ directory
      2. NEVER create errors/ directory until Sheet 6
      3. Keep ALL original code - no functionality changes
      4. Use relative imports within the package (e.g., `from .codes import`)
      5. Sheet 6 does the atomic swap and verifies imports

validations:
  # Sheet 1: codes.py created
  - type: file_exists
    path: "src/mozart/core/errors_staging/codes.py"
    description: "codes.py module must exist"
    condition: "sheet_num >= 1"

  # Sheet 2: models.py created
  - type: file_exists
    path: "src/mozart/core/errors_staging/models.py"
    description: "models.py module must exist"
    condition: "sheet_num >= 2"

  # Sheet 3: signals.py created
  - type: file_exists
    path: "src/mozart/core/errors_staging/signals.py"
    description: "signals.py module must exist"
    condition: "sheet_num >= 3"

  # Sheet 4: parsers.py created
  - type: file_exists
    path: "src/mozart/core/errors_staging/parsers.py"
    description: "parsers.py module must exist"
    condition: "sheet_num >= 4"

  # Sheet 5: classifier.py created
  - type: file_exists
    path: "src/mozart/core/errors_staging/classifier.py"
    description: "classifier.py module must exist"
    condition: "sheet_num >= 5"

  # Sheet 6: __init__.py + imports work
  - type: file_exists
    path: "src/mozart/core/errors/__init__.py"
    description: "Package __init__.py must exist"
    condition: "sheet_num == 6"

  - type: command_succeeds
    command: "python -c 'from mozart.core.errors import ErrorCode, ErrorClassifier, ClassifiedError; print(\"OK\")'"
    description: "Imports must work after modularization"
    condition: "sheet_num == 6"

# Chain to D2 on success
on_success:
  - type: run_job
    job_path: "modularization-d2.yaml"
    description: "Chain to D2: global_store.py modularization"
    detached: true  # Run independently to avoid 300s hook timeout

concert:
  enabled: true
  max_chain_depth: 10
  cooldown_between_jobs_seconds: 30
  inherit_workspace: false
