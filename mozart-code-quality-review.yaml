# ╔══════════════════════════════════════════════════════════════════════════════╗
# ║              MOZART CODE QUALITY REVIEW EVOLUTION                            ║
# ║                                                                              ║
# ║  "Quality emerges from multiple perspectives seeing the same truth"          ║
# ║                                                                              ║
# ║  Problem: Code quality issues accumulating - unwired components, dead code,  ║
# ║           missing tests, incomplete documentation                            ║
# ║                                                                              ║
# ║  Approach: TDF-aligned expert review from 5 perspectives, then remediation   ║
# ║                                                                              ║
# ║  Structure:                                                                  ║
# ║    Movement I   (Sheets 1-5): Expert Reviews - One per TDF domain            ║
# ║    Movement II  (Sheet 6):    Synthesis - Prioritized issue triage           ║
# ║    Movement III (Sheets 7-9): Remediation - Fix high-priority issues         ║
# ║                                                                              ║
# ╚══════════════════════════════════════════════════════════════════════════════╝

name: code-quality-review
description: |
  Multi-perspective code quality review with TDF-aligned expert analysis.
  Identifies unwired components, dead code, missing tests, and remediates.

workspace: code-quality-workspace

backend:
  type: claude_cli
  model: claude-sonnet-4-20250514
  timeout_seconds: 2400
  output_format: text
  working_directory: /home/emzi/Projects/mozart-ai-compose

prompt:
  template: |
    {{ preamble }}

    {% if sheet_num == 1 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  EXPERT REVIEW 1: ARCHITECTURE ANALYST (COMP Domain)                         ║
    ║  "Structure reveals intent; misalignment reveals debt"                       ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    You are the **Architecture Analyst**, focused on structural integrity.

    Your expertise: Code organization, module boundaries, dependency flow,
    interface design, separation of concerns, SOLID principles.

    ═══════════════════════════════════════════════════════════════════════════════
    INVESTIGATION PROTOCOL
    ═══════════════════════════════════════════════════════════════════════════════

    1. **MODULE STRUCTURE ANALYSIS**
       ```bash
       # Map the module hierarchy
       find src/mozart -type f -name "*.py" | head -50

       # Check for circular imports
       grep -r "from mozart" src/mozart --include="*.py" | \
         grep -v "__pycache__" | \
         awk -F: '{print $1 " imports " $2}' | head -30
       ```

       Questions to answer:
       - Are modules cohesive (single responsibility)?
       - Are there circular dependencies?
       - Is the directory structure logical?

    2. **INTERFACE CONSISTENCY CHECK**
       ```bash
       # Find all Protocol/ABC definitions
       grep -rn "class.*Protocol\|class.*ABC\|@abstractmethod" src/mozart/

       # Find implementations
       grep -rn "def __init__" src/mozart/backends/ src/mozart/state/
       ```

       Questions to answer:
       - Do all backends implement the same interface?
       - Are there inconsistent method signatures?
       - Are abstractions used consistently?

    3. **UNWIRED COMPONENTS DETECTION**
       ```bash
       # Find classes that might not be instantiated
       for cls in $(grep -rh "^class " src/mozart/ | sed 's/class \([^(:]*\).*/\1/' | sort -u); do
         count=$(grep -r "$cls(" src/mozart/ --include="*.py" | grep -v "^.*:class " | wc -l)
         if [ "$count" -eq 0 ]; then
           echo "POTENTIALLY UNWIRED: $cls"
         fi
       done

       # Find imports that are defined but never used in the module
       # Check for functions defined but not called
       ```

    4. **DEPENDENCY FLOW ANALYSIS**
       ```bash
       # Check what imports what
       grep -r "^from mozart\." src/mozart/ --include="*.py" | \
         awk -F: '{split($2, a, " "); print $1 " -> " a[2]}' | \
         sort -u | head -40
       ```

    ═══════════════════════════════════════════════════════════════════════════════
    OUTPUT FORMAT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/01-architecture-review.md

    ```markdown
    # Expert Review 1: Architecture Analysis (COMP)

    ## Module Structure Assessment

    ### Cohesion Score: [A-F]
    [Analysis of module responsibilities]

    ### Coupling Assessment
    [Dependency graph issues]

    ## Unwired Components Found

    | Component | Location | Evidence | Severity |
    |-----------|----------|----------|----------|
    | [class/function] | [file:line] | [why unwired] | [high/med/low] |

    ## Interface Inconsistencies

    [List any protocol/interface violations]

    ## Structural Debt Items

    1. **[Issue]**: [description]
       - Location: [file:line]
       - Impact: [what breaks or is degraded]
       - Suggested fix: [brief recommendation]

    ## Prioritized Findings (Top 5)

    1. [Most critical structural issue]
    2. ...
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER ({{ workspace }}/sheet1-result.md)
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 1
    EXPERT: Architecture Analyst (COMP)
    MODULES_ANALYZED: [count]
    UNWIRED_COMPONENTS_FOUND: [count]
    INTERFACE_ISSUES: [count]
    STRUCTURAL_DEBT_ITEMS: [count]
    TOP_PRIORITY_ISSUE: [brief description]
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 2 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  EXPERT REVIEW 2: TEST COVERAGE ANALYST (SCI Domain)                         ║
    ║  "Untested code is unverified code; unverified code is unknown code"         ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    You are the **Test Coverage Analyst**, focused on empirical verification.

    Your expertise: Test coverage metrics, test quality, edge cases,
    regression prevention, test organization, mocking strategies.

    ═══════════════════════════════════════════════════════════════════════════════
    INVESTIGATION PROTOCOL
    ═══════════════════════════════════════════════════════════════════════════════

    1. **COVERAGE MEASUREMENT**
       ```bash
       cd /home/emzi/Projects/mozart-ai-compose

       # Run coverage if available
       .venv/bin/python -m pytest tests/ --cov=src/mozart --cov-report=term-missing \
         -q --tb=no 2>&1 | tail -100 || echo "Coverage not configured"

       # Count test files vs source files
       echo "Source files: $(find src/mozart -name '*.py' | wc -l)"
       echo "Test files: $(find tests -name 'test_*.py' | wc -l)"
       ```

    2. **UNTESTED MODULE DETECTION**
       ```bash
       # Find source modules
       for module in $(find src/mozart -name "*.py" -not -name "__init__.py" | \
         sed 's|src/mozart/||' | sed 's|\.py||' | sed 's|/|_|g'); do
         # Check if corresponding test exists
         if ! find tests -name "test_*$module*" -o -name "*${module}*test*" 2>/dev/null | grep -q .; then
           echo "NO TEST: $module"
         fi
       done

       # List all test files
       find tests -name "test_*.py" -exec basename {} \; | sort
       ```

    3. **TEST QUALITY ASSESSMENT**
       ```bash
       # Check for assertions in tests
       grep -r "assert\|pytest.raises\|self.assert" tests/ | wc -l

       # Check for mocking
       grep -r "Mock\|patch\|MagicMock" tests/ | wc -l

       # Check for parameterized tests
       grep -r "@pytest.mark.parametrize\|@parameterized" tests/ | wc -l

       # Find tests with no assertions (potential false positives)
       for f in tests/test_*.py; do
         if ! grep -q "assert" "$f" 2>/dev/null; then
           echo "NO ASSERTIONS: $f"
         fi
       done
       ```

    4. **CRITICAL PATH COVERAGE**
       ```bash
       # Check if critical modules have tests
       critical_modules="runner validation errors checkpoint config"
       for mod in $critical_modules; do
         echo "=== $mod ==="
         find tests -name "*$mod*" -type f
       done
       ```

    ═══════════════════════════════════════════════════════════════════════════════
    OUTPUT FORMAT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/02-test-coverage-review.md

    ```markdown
    # Expert Review 2: Test Coverage Analysis (SCI)

    ## Coverage Metrics

    - Overall coverage: [X%]
    - Source files: [N]
    - Test files: [N]
    - Ratio: [test files / source files]

    ## Untested Modules

    | Module | Lines of Code | Risk Level | Why Critical |
    |--------|--------------|------------|--------------|
    | [module] | [LOC] | [high/med/low] | [importance] |

    ## Test Quality Issues

    - Tests without assertions: [count]
    - Missing edge case coverage: [list]
    - Brittle tests (hardcoded values): [list]

    ## Critical Paths Without Tests

    1. **[Path]**: [description]
       - Location: [file:line range]
       - Risk: [what could go wrong undetected]

    ## Prioritized Testing Gaps (Top 5)

    1. [Most critical untested functionality]
    2. ...
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER ({{ workspace }}/sheet2-result.md)
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 2
    EXPERT: Test Coverage Analyst (SCI)
    COVERAGE_PERCENT: [X%]
    UNTESTED_MODULES: [count]
    TEST_QUALITY_ISSUES: [count]
    CRITICAL_GAPS: [count]
    TOP_PRIORITY_GAP: [brief description]
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 3 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  EXPERT REVIEW 3: DOCUMENTATION AUDITOR (CULT Domain)                        ║
    ║  "Code tells how; documentation tells why"                                   ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    You are the **Documentation Auditor**, focused on knowledge transfer.

    Your expertise: Docstrings, README quality, inline comments, API docs,
    type hints, example code, architectural decision records.

    ═══════════════════════════════════════════════════════════════════════════════
    INVESTIGATION PROTOCOL
    ═══════════════════════════════════════════════════════════════════════════════

    1. **DOCSTRING COVERAGE**
       ```bash
       cd /home/emzi/Projects/mozart-ai-compose

       # Count functions/methods without docstrings
       for f in $(find src/mozart -name "*.py"); do
         # Count def statements
         defs=$(grep -c "^\s*def " "$f" 2>/dev/null || echo 0)
         # Count docstrings after def (rough heuristic)
         docs=$(grep -A1 "^\s*def " "$f" 2>/dev/null | grep -c '"""' || echo 0)
         if [ "$defs" -gt 0 ] && [ "$docs" -lt "$defs" ]; then
           echo "$f: $docs/$defs documented"
         fi
       done | head -20

       # Find public functions without docstrings
       grep -rn "^def [^_]" src/mozart/ --include="*.py" | head -20
       ```

    2. **TYPE HINT COVERAGE**
       ```bash
       # Functions with return type hints
       grep -r "def.*->.*:" src/mozart/ --include="*.py" | wc -l

       # Functions without return type hints
       grep -r "def.*):$" src/mozart/ --include="*.py" | wc -l

       # Check for Any usage (weak typing)
       grep -r ": Any\|-> Any" src/mozart/ --include="*.py" | wc -l
       ```

    3. **README AND DOCS ASSESSMENT**
       ```bash
       # Check documentation files
       find . -name "README*" -o -name "*.md" | grep -v node_modules | head -20

       # Check for outdated docs (files not modified recently)
       find docs -name "*.md" -mtime +90 2>/dev/null | head -10

       # Look for TODO/FIXME/XXX in docs
       grep -r "TODO\|FIXME\|XXX\|HACK" docs/ *.md 2>/dev/null | head -10
       ```

    4. **API DOCUMENTATION**
       ```bash
       # Check if public APIs have docstrings
       grep -B5 "^class\|^def " src/mozart/cli.py | head -50

       # Check config documentation
       head -100 src/mozart/core/config.py
       ```

    ═══════════════════════════════════════════════════════════════════════════════
    OUTPUT FORMAT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/03-documentation-review.md

    ```markdown
    # Expert Review 3: Documentation Audit (CULT)

    ## Docstring Coverage

    - Functions with docstrings: [X%]
    - Classes with docstrings: [X%]
    - Modules with module docstrings: [X%]

    ## Type Hint Coverage

    - Functions with return types: [N]
    - Functions without return types: [N]
    - Usage of Any (weak typing): [N occurrences]

    ## Undocumented Public APIs

    | API | Location | Impact |
    |-----|----------|--------|
    | [function/class] | [file:line] | [who needs this doc] |

    ## Documentation Debt

    1. **[Issue]**: [description]
       - Location: [file or doc]
       - Impact: [who is confused]

    ## Stale or Misleading Documentation

    [List docs that may be out of date]

    ## Prioritized Documentation Gaps (Top 5)

    1. [Most critical missing documentation]
    2. ...
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER ({{ workspace }}/sheet3-result.md)
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 3
    EXPERT: Documentation Auditor (CULT)
    DOCSTRING_COVERAGE: [X%]
    TYPE_HINT_COVERAGE: [X%]
    UNDOCUMENTED_APIS: [count]
    STALE_DOCS: [count]
    TOP_PRIORITY_GAP: [brief description]
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 4 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  EXPERT REVIEW 4: CODE SMELL DETECTOR (EXP Domain)                           ║
    ║  "Bad code smells; good code flows"                                          ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    You are the **Code Smell Detector**, focused on intuitive quality.

    Your expertise: Code smells, anti-patterns, complexity, readability,
    maintainability, "WTF per minute" reduction.

    ═══════════════════════════════════════════════════════════════════════════════
    INVESTIGATION PROTOCOL
    ═══════════════════════════════════════════════════════════════════════════════

    1. **COMPLEXITY ANALYSIS**
       ```bash
       cd /home/emzi/Projects/mozart-ai-compose

       # Find long functions (>50 lines)
       awk '/^def /{name=$2; start=NR} /^def |^class /{if(NR-start>50) print FILENAME":"start" "name" ("NR-start" lines)"}' \
         src/mozart/**/*.py 2>/dev/null | head -20

       # Find deeply nested code (4+ levels)
       grep -rn "^\s\{16,\}" src/mozart/ --include="*.py" | head -20

       # Count lines per file
       wc -l src/mozart/**/*.py 2>/dev/null | sort -rn | head -15
       ```

    2. **DUPLICATE CODE DETECTION**
       ```bash
       # Find similar function names (potential duplicates)
       grep -rh "^def " src/mozart/ --include="*.py" | \
         sed 's/def \([^(]*\).*/\1/' | sort | uniq -c | sort -rn | \
         awk '$1 > 1 {print}' | head -15

       # Find repeated string literals
       grep -roh '"[^"]\{20,\}"' src/mozart/ --include="*.py" | \
         sort | uniq -c | sort -rn | head -10
       ```

    3. **DEAD CODE DETECTION**
       ```bash
       # Find imports that might be unused
       for f in src/mozart/**/*.py; do
         imports=$(grep "^from\|^import" "$f" 2>/dev/null | \
           sed 's/.*import \([^,]*\).*/\1/' | sed 's/ as .*//')
         for imp in $imports; do
           # Check if import is used in file (excluding import line)
           if ! grep -q "$imp" "$f" 2>/dev/null | grep -v "import"; then
             echo "POSSIBLY UNUSED: $imp in $f"
           fi
         done
       done 2>/dev/null | head -20

       # Find functions that are never called
       # (heuristic: defined but name doesn't appear elsewhere)
       ```

    4. **CODE SMELL PATTERNS**
       ```bash
       # God classes (too many methods)
       for f in src/mozart/**/*.py; do
         methods=$(grep -c "^\s*def " "$f" 2>/dev/null || echo 0)
         if [ "$methods" -gt 20 ]; then
           echo "LARGE CLASS: $f ($methods methods)"
         fi
       done

       # Long parameter lists
       grep -rn "def.*,.*,.*,.*,.*," src/mozart/ --include="*.py" | head -10

       # Magic numbers
       grep -rn "[^0-9][0-9]\{3,\}[^0-9]" src/mozart/ --include="*.py" | \
         grep -v "port\|timeout\|size\|limit" | head -10
       ```

    5. **INTUITION CHECK** (Read these files and assess)
       ```bash
       # Read the largest/most complex files
       head -200 src/mozart/execution/runner.py
       head -200 src/mozart/core/errors.py
       ```

       Ask yourself:
       - Would a new developer understand this?
       - Are there "clever" tricks that should be simpler?
       - Does the code flow naturally?

    ═══════════════════════════════════════════════════════════════════════════════
    OUTPUT FORMAT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/04-code-smell-review.md

    ```markdown
    # Expert Review 4: Code Smell Analysis (EXP)

    ## Complexity Hotspots

    | File | Lines | Methods | Complexity Issue |
    |------|-------|---------|------------------|
    | [file] | [LOC] | [count] | [description] |

    ## Duplicate Code

    | Pattern | Occurrences | Locations |
    |---------|-------------|-----------|
    | [description] | [N] | [files] |

    ## Dead Code Candidates

    | Code | Location | Confidence |
    |------|----------|------------|
    | [function/import] | [file:line] | [high/med/low] |

    ## Code Smells Found

    1. **[Smell Type]**: [description]
       - Location: [file:line]
       - Gut reaction: [how it feels to read]
       - Suggested refactor: [brief]

    ## Readability Issues

    [Areas that made you go "WTF?"]

    ## Prioritized Smells (Top 5)

    1. [Most offensive code smell]
    2. ...
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER ({{ workspace }}/sheet4-result.md)
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 4
    EXPERT: Code Smell Detector (EXP)
    COMPLEXITY_HOTSPOTS: [count]
    DUPLICATE_PATTERNS: [count]
    DEAD_CODE_CANDIDATES: [count]
    CODE_SMELLS: [count]
    TOP_PRIORITY_SMELL: [brief description]
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 5 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  EXPERT REVIEW 5: PATTERN ANALYST (META Domain)                              ║
    ║  "Patterns in patterns reveal the system's true nature"                      ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    You are the **Pattern Analyst**, focused on meta-level consistency.

    Your expertise: Design patterns, anti-patterns, consistency across modules,
    naming conventions, error handling patterns, logging patterns.

    ═══════════════════════════════════════════════════════════════════════════════
    INVESTIGATION PROTOCOL
    ═══════════════════════════════════════════════════════════════════════════════

    1. **NAMING CONVENTION ANALYSIS**
       ```bash
       cd /home/emzi/Projects/mozart-ai-compose

       # Check class naming consistency
       grep -rh "^class " src/mozart/ --include="*.py" | \
         sed 's/class \([^(:]*\).*/\1/' | sort -u | head -30

       # Check function naming (should be snake_case)
       grep -rh "^\s*def " src/mozart/ --include="*.py" | \
         sed 's/.*def \([^(]*\).*/\1/' | grep -v "^_" | \
         grep "[A-Z]" | head -10  # Find non-snake_case

       # Check constant naming (should be UPPER_CASE)
       grep -rn "^[A-Z_]\+\s*=" src/mozart/ --include="*.py" | head -15
       ```

    2. **ERROR HANDLING PATTERNS**
       ```bash
       # How are errors raised?
       grep -rn "raise " src/mozart/ --include="*.py" | head -20

       # Custom exception classes
       grep -rn "class.*Exception\|class.*Error" src/mozart/ --include="*.py"

       # Bare except clauses (anti-pattern)
       grep -rn "except:" src/mozart/ --include="*.py"

       # Exception handling consistency
       grep -rn "except.*Exception" src/mozart/ --include="*.py" | head -15
       ```

    3. **LOGGING PATTERNS**
       ```bash
       # Different logging approaches used
       grep -rn "logger\.\|logging\.\|self\._logger\.\|_logger\." src/mozart/ --include="*.py" | \
         sed 's/.*\(logger\|logging\|_logger\)\.\([^(]*\).*/\2/' | sort | uniq -c | sort -rn

       # Check for print statements (should use logging)
       grep -rn "^[^#]*print(" src/mozart/ --include="*.py" | head -10
       ```

    4. **DESIGN PATTERN CONSISTENCY**
       ```bash
       # Factory patterns
       grep -rn "Factory\|create_\|build_" src/mozart/ --include="*.py" | head -15

       # Singleton patterns
       grep -rn "_instance\|getInstance\|__new__" src/mozart/ --include="*.py" | head -10

       # Observer/callback patterns
       grep -rn "callback\|listener\|observer\|on_\|handler" src/mozart/ --include="*.py" | head -15
       ```

    5. **CROSS-MODULE CONSISTENCY**
       Read multiple modules and compare:
       - How do different backends handle errors?
       - How do different modules log?
       - Are similar operations done similarly?

    ═══════════════════════════════════════════════════════════════════════════════
    OUTPUT FORMAT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/05-pattern-review.md

    ```markdown
    # Expert Review 5: Pattern Analysis (META)

    ## Naming Convention Violations

    | Violation | Location | Convention Expected |
    |-----------|----------|---------------------|
    | [name] | [file:line] | [snake_case/PascalCase/etc] |

    ## Error Handling Inconsistencies

    - Custom exceptions: [list]
    - Bare except clauses: [count]
    - Inconsistent patterns: [description]

    ## Logging Pattern Issues

    - Logger styles found: [list different approaches]
    - Print statements (should be logging): [count]
    - Missing logging in critical paths: [list]

    ## Design Pattern Observations

    | Pattern | Usage | Consistency |
    |---------|-------|-------------|
    | [Factory/Singleton/etc] | [where used] | [consistent/inconsistent] |

    ## Cross-Module Inconsistencies

    1. **[Inconsistency]**: [description]
       - Module A does: [approach]
       - Module B does: [different approach]
       - Recommendation: [which to standardize on]

    ## Anti-Patterns Detected

    [List any recognized anti-patterns]

    ## Prioritized Pattern Issues (Top 5)

    1. [Most impactful pattern inconsistency]
    2. ...
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER ({{ workspace }}/sheet5-result.md)
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 5
    EXPERT: Pattern Analyst (META)
    NAMING_VIOLATIONS: [count]
    ERROR_HANDLING_ISSUES: [count]
    LOGGING_ISSUES: [count]
    ANTI_PATTERNS: [count]
    TOP_PRIORITY_ISSUE: [brief description]
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 6 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  MOVEMENT II: SYNTHESIS & TRIAGE                                             ║
    ║  "Wisdom is knowing which battles to fight first"                            ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    You are the **Quality Coordinator**, synthesizing all expert findings.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 1: LOAD ALL EXPERT REVIEWS
    ═══════════════════════════════════════════════════════════════════════════════

    Read all five expert review documents:
    - {{ workspace }}/01-architecture-review.md
    - {{ workspace }}/02-test-coverage-review.md
    - {{ workspace }}/03-documentation-review.md
    - {{ workspace }}/04-code-smell-review.md
    - {{ workspace }}/05-pattern-review.md

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 2: CROSS-REFERENCE FINDINGS
    ═══════════════════════════════════════════════════════════════════════════════

    Look for issues identified by multiple experts:
    - If COMP and EXP both flag something → higher priority
    - If SCI and CULT both flag something → higher priority
    - Convergent findings indicate systemic issues

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 3: PRIORITIZATION MATRIX
    ═══════════════════════════════════════════════════════════════════════════════

    Score each finding on:
    - **Impact**: How much does this affect users/developers? (1-5)
    - **Effort**: How hard is this to fix? (1-5, lower = easier)
    - **Risk**: What's the risk of NOT fixing this? (1-5)
    - **Dependencies**: Does fixing this enable other fixes? (yes/no)

    Priority = (Impact × Risk) / Effort + (Dependencies ? 2 : 0)

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 4: REMEDIATION PLAN
    ═══════════════════════════════════════════════════════════════════════════════

    Group findings into remediation buckets:

    **Sheet 7: Quick Wins** (Effort ≤ 2, can fix in <30 min each)
    - Dead imports
    - Missing docstrings on public APIs
    - Simple naming fixes
    - Print → logging conversions

    **Sheet 8: Structural Fixes** (Effort 3-4, requires careful work)
    - Unwired components
    - Interface inconsistencies
    - Missing tests for critical paths
    - Error handling standardization

    **Sheet 9: Refactoring** (Effort 5, requires significant change)
    - Complex function decomposition
    - Duplicate code consolidation
    - Major pattern alignment

    ═══════════════════════════════════════════════════════════════════════════════
    OUTPUT FORMAT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/06-synthesis-triage.md

    ```markdown
    # Movement II: Synthesis & Triage

    ## Cross-Expert Convergence

    | Issue | Flagged By | Convergence Score |
    |-------|------------|-------------------|
    | [issue] | COMP, EXP | 2 |
    | [issue] | SCI, CULT, META | 3 |

    ## Prioritization Matrix

    | Issue | Impact | Effort | Risk | Deps | Priority Score |
    |-------|--------|--------|------|------|----------------|
    | [issue] | 5 | 2 | 4 | yes | 12 |

    ## Remediation Plan

    ### Sheet 7: Quick Wins (Target: 8-12 fixes)
    1. [fix] - [location] - [effort: 1]
    2. ...

    ### Sheet 8: Structural Fixes (Target: 3-5 fixes)
    1. [fix] - [location] - [effort: 3]
    2. ...

    ### Sheet 9: Refactoring (Target: 1-2 fixes)
    1. [fix] - [location] - [effort: 5]
    2. ...

    ## Deferred Items (Future Evolution)

    [Items that are important but out of scope]
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER ({{ workspace }}/sheet6-result.md)
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 6
    PHASE: Synthesis & Triage
    TOTAL_ISSUES_FOUND: [count across all experts]
    CONVERGENT_ISSUES: [count flagged by 2+ experts]
    QUICK_WINS_PLANNED: [count]
    STRUCTURAL_FIXES_PLANNED: [count]
    REFACTORING_PLANNED: [count]
    DEFERRED: [count]
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 7 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  MOVEMENT III-A: QUICK WINS REMEDIATION                                      ║
    ║  "Small improvements compound; momentum builds momentum"                     ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    You are now **executing remediation**. Focus on quick wins from the triage.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 1: LOAD REMEDIATION PLAN
    ═══════════════════════════════════════════════════════════════════════════════

    Read: {{ workspace }}/06-synthesis-triage.md

    Extract the "Sheet 7: Quick Wins" section. These are your targets.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 2: EXECUTE QUICK FIXES
    ═══════════════════════════════════════════════════════════════════════════════

    For each quick win:
    1. Locate the issue
    2. Make the fix
    3. Verify the fix (run relevant test or check)
    4. Record what was done

    Common quick fixes:
    - Remove unused imports
    - Add missing docstrings to public functions
    - Convert print() to logging
    - Fix naming convention violations
    - Remove dead code
    - Add type hints to function signatures

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 3: VERIFY CHANGES
    ═══════════════════════════════════════════════════════════════════════════════

    ```bash
    cd /home/emzi/Projects/mozart-ai-compose

    # Type check
    .venv/bin/python -m mypy src/mozart/ --ignore-missing-imports 2>&1 | tail -20

    # Import check
    .venv/bin/python -c "from mozart.cli import app; print('Imports OK')"

    # Quick test run
    .venv/bin/python -m pytest tests/ -q --tb=no 2>&1 | tail -10
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 4: COMMIT
    ═══════════════════════════════════════════════════════════════════════════════

    ```bash
    git add -A
    git commit -m "refactor: Quick wins code quality fixes

    - [list of fixes made]

    Part of code-quality-review evolution (Sheet 7/9)

    Co-Authored-By: Claude Sonnet 4 <noreply@anthropic.com>"
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    OUTPUT FORMAT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/07-quick-wins-remediation.md

    ```markdown
    # Movement III-A: Quick Wins Remediation

    ## Fixes Applied

    | Fix | Location | Type | Verified |
    |-----|----------|------|----------|
    | [description] | [file:line] | [import/docstring/etc] | ✓ |

    ## Verification Results

    - mypy: [pass/fail]
    - imports: [pass/fail]
    - tests: [X passed, Y failed]

    ## Commit

    Hash: [commit hash]
    Files changed: [count]
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER ({{ workspace }}/sheet7-result.md)
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 7
    PHASE: Quick Wins Remediation
    FIXES_PLANNED: [count from triage]
    FIXES_APPLIED: [count]
    MYPY_PASSED: [yes/no]
    TESTS_PASSED: [yes/no]
    COMMIT_HASH: [hash]
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 8 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  MOVEMENT III-B: STRUCTURAL FIXES REMEDIATION                                ║
    ║  "Structure supports function; fix structure to enable function"             ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    You are now **executing structural remediation**. These require more care.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 1: LOAD REMEDIATION PLAN
    ═══════════════════════════════════════════════════════════════════════════════

    Read: {{ workspace }}/06-synthesis-triage.md

    Extract the "Sheet 8: Structural Fixes" section. Plan carefully before acting.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 2: EXECUTE STRUCTURAL FIXES
    ═══════════════════════════════════════════════════════════════════════════════

    For each structural fix:
    1. Understand the current state thoroughly
    2. Plan the change
    3. Make the change incrementally
    4. Test after each increment
    5. Document what changed and why

    Common structural fixes:
    - Wire up unwired components (connect to usage point)
    - Standardize error handling across modules
    - Add missing tests for critical paths
    - Fix interface inconsistencies
    - Consolidate duplicate code into shared utilities

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 3: COMPREHENSIVE VERIFICATION
    ═══════════════════════════════════════════════════════════════════════════════

    ```bash
    cd /home/emzi/Projects/mozart-ai-compose

    # Full type check
    .venv/bin/python -m mypy src/mozart/ --ignore-missing-imports

    # Full test suite
    .venv/bin/python -m pytest tests/ -v --tb=short 2>&1 | tail -50

    # Import all modules
    .venv/bin/python -c "
    from mozart.cli import app
    from mozart.execution.runner import JobRunner
    from mozart.learning.global_store import GlobalLearningStore
    from mozart.learning.aggregator import EnhancedPatternAggregator
    print('All critical imports OK')
    "
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 4: COMMIT
    ═══════════════════════════════════════════════════════════════════════════════

    ```bash
    git add -A
    git commit -m "refactor: Structural code quality fixes

    - [list of structural changes]

    Part of code-quality-review evolution (Sheet 8/9)

    Co-Authored-By: Claude Sonnet 4 <noreply@anthropic.com>"
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    OUTPUT FORMAT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/08-structural-remediation.md

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER ({{ workspace }}/sheet8-result.md)
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 8
    PHASE: Structural Fixes Remediation
    FIXES_PLANNED: [count from triage]
    FIXES_APPLIED: [count]
    TESTS_ADDED: [count]
    MYPY_PASSED: [yes/no]
    TESTS_PASSED: [yes/no]
    COMMIT_HASH: [hash]
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 9 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  MOVEMENT III-C: REFACTORING & SUMMARY                                       ║
    ║  "Refactoring is paying down debt to invest in the future"                   ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    You are now **executing refactoring** and summarizing the evolution.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 1: CAUTIOUS REFACTORING
    ═══════════════════════════════════════════════════════════════════════════════

    Read: {{ workspace }}/06-synthesis-triage.md

    Extract "Sheet 9: Refactoring" section. These are high-effort changes.

    **Rules for refactoring:**
    - Only attempt if tests exist for the area
    - Make one logical change at a time
    - Run tests after each change
    - If tests fail, revert and reconsider
    - Document the refactoring rationale

    If the refactoring is too risky, document why and defer.

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 2: FINAL VERIFICATION
    ═══════════════════════════════════════════════════════════════════════════════

    ```bash
    cd /home/emzi/Projects/mozart-ai-compose

    # Full test suite
    .venv/bin/python -m pytest tests/ -v 2>&1 | tail -30

    # Type check
    .venv/bin/python -m mypy src/mozart/ --ignore-missing-imports 2>&1 | tail -10

    # CLI smoke test
    .venv/bin/mozart --help
    .venv/bin/mozart learning-stats 2>&1 | head -20
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 3: EVOLUTION SUMMARY
    ═══════════════════════════════════════════════════════════════════════════════

    Write comprehensive summary to: {{ workspace }}/09-evolution-summary.md

    Include:
    - Total issues found by each expert
    - Total fixes applied
    - What was deferred and why
    - Recommendations for next quality evolution
    - Lessons learned

    ═══════════════════════════════════════════════════════════════════════════════
    PHASE 4: FINAL COMMIT
    ═══════════════════════════════════════════════════════════════════════════════

    ```bash
    git add -A
    git commit -m "refactor: Complete code quality review evolution

    Expert reviews completed:
    - Architecture (COMP): [findings]
    - Test Coverage (SCI): [findings]
    - Documentation (CULT): [findings]
    - Code Smells (EXP): [findings]
    - Patterns (META): [findings]

    Remediation:
    - Quick wins: [count] fixes
    - Structural: [count] fixes
    - Refactoring: [count] changes

    Co-Authored-By: Claude Sonnet 4 <noreply@anthropic.com>"
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER ({{ workspace }}/sheet9-result.md)
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 9
    PHASE: Refactoring & Summary
    REFACTORING_ATTEMPTED: [count]
    REFACTORING_COMPLETED: [count]
    REFACTORING_DEFERRED: [count]
    TOTAL_FIXES_THIS_EVOLUTION: [count]
    TESTS_PASSING: [yes/no]
    FINAL_COMMIT_HASH: [hash]
    EVOLUTION_COMPLETE: yes
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% endif %}

    {{ stakes }}

  variables:
    preamble: |
      ╔══════════════════════════════════════════════════════════════════════════╗
      ║              MOZART CODE QUALITY REVIEW EVOLUTION                        ║
      ╚══════════════════════════════════════════════════════════════════════════╝

      You are executing a TDF-aligned code quality review of the Mozart codebase.

      EXPERT PERSPECTIVES (TDF Domains):
      - COMP (Architecture Analyst): Structure, dependencies, interfaces
      - SCI (Test Coverage Analyst): Tests, coverage, verification
      - CULT (Documentation Auditor): Docs, types, knowledge transfer
      - EXP (Code Smell Detector): Complexity, readability, intuition
      - META (Pattern Analyst): Consistency, conventions, anti-patterns

      CURRENT SHEET: {{ sheet_num }} of 9
      WORKSPACE: {{ workspace }}

      PROJECT: /home/emzi/Projects/mozart-ai-compose
      KEY AREAS:
      - src/mozart/execution/ - Job runner, validation, retry
      - src/mozart/learning/ - Global learning, patterns, aggregation
      - src/mozart/backends/ - Claude CLI, Anthropic API
      - src/mozart/core/ - Config, checkpoint, errors
      - tests/ - Test suite

    stakes: |
      ═══════════════════════════════════════════════════════════════════════════
      STAKES
      ═══════════════════════════════════════════════════════════════════════════

      Code quality issues compound. We just found that OutputPatternExtractor
      was built but never wired up. How many other components are in this state?

      This evolution systematically reviews the codebase from 5 expert perspectives,
      synthesizes findings, and remediates issues in priority order.

      The goal: A cleaner, more consistent, better-tested codebase where
      new features are less likely to be built but never connected.

sheet:
  total_items: 9
  size: 1

retry:
  max_retries: 3
  base_delay_seconds: 60

validations:
  # ═══════════════════════════════════════════════════════════════════════════
  # MOVEMENT I: Expert Reviews
  # ═══════════════════════════════════════════════════════════════════════════

  # Sheet 1: Architecture Review
  - type: file_exists
    path: "{workspace}/01-architecture-review.md"
    description: "Architecture review exists"
    condition: "sheet_num >= 1"

  - type: content_contains
    path: "{workspace}/01-architecture-review.md"
    pattern: "Unwired Components"
    description: "Architecture review includes unwired components section"
    condition: "sheet_num >= 1"

  # Sheet 2: Test Coverage Review
  - type: file_exists
    path: "{workspace}/02-test-coverage-review.md"
    description: "Test coverage review exists"
    condition: "sheet_num >= 2"

  - type: content_contains
    path: "{workspace}/02-test-coverage-review.md"
    pattern: "Untested"
    description: "Test coverage review identifies untested areas"
    condition: "sheet_num >= 2"

  # Sheet 3: Documentation Review
  - type: file_exists
    path: "{workspace}/03-documentation-review.md"
    description: "Documentation review exists"
    condition: "sheet_num >= 3"

  - type: content_contains
    path: "{workspace}/03-documentation-review.md"
    pattern: "Docstring"
    description: "Documentation review covers docstrings"
    condition: "sheet_num >= 3"

  # Sheet 4: Code Smell Review
  - type: file_exists
    path: "{workspace}/04-code-smell-review.md"
    description: "Code smell review exists"
    condition: "sheet_num >= 4"

  - type: content_contains
    path: "{workspace}/04-code-smell-review.md"
    pattern: "Complexity"
    description: "Code smell review covers complexity"
    condition: "sheet_num >= 4"

  # Sheet 5: Pattern Review
  - type: file_exists
    path: "{workspace}/05-pattern-review.md"
    description: "Pattern review exists"
    condition: "sheet_num >= 5"

  - type: content_contains
    path: "{workspace}/05-pattern-review.md"
    pattern: "Naming"
    description: "Pattern review covers naming conventions"
    condition: "sheet_num >= 5"

  # ═══════════════════════════════════════════════════════════════════════════
  # MOVEMENT II: Synthesis
  # ═══════════════════════════════════════════════════════════════════════════

  # Sheet 6: Synthesis & Triage
  - type: file_exists
    path: "{workspace}/06-synthesis-triage.md"
    description: "Synthesis document exists"
    condition: "sheet_num >= 6"

  - type: content_contains
    path: "{workspace}/06-synthesis-triage.md"
    pattern: "Quick Wins"
    description: "Synthesis includes quick wins section"
    condition: "sheet_num >= 6"

  - type: content_contains
    path: "{workspace}/06-synthesis-triage.md"
    pattern: "Structural"
    description: "Synthesis includes structural fixes section"
    condition: "sheet_num >= 6"

  # ═══════════════════════════════════════════════════════════════════════════
  # MOVEMENT III: Remediation
  # ═══════════════════════════════════════════════════════════════════════════

  # Sheet 7: Quick Wins
  - type: file_exists
    path: "{workspace}/07-quick-wins-remediation.md"
    description: "Quick wins remediation report exists"
    condition: "sheet_num >= 7"

  - type: content_regex
    path: "{workspace}/sheet7-result.md"
    pattern: "FIXES_APPLIED: [0-9]+"
    description: "Quick wins applied count recorded"
    condition: "sheet_num >= 7"

  # Sheet 8: Structural Fixes
  - type: file_exists
    path: "{workspace}/08-structural-remediation.md"
    description: "Structural remediation report exists"
    condition: "sheet_num >= 8"

  - type: content_regex
    path: "{workspace}/sheet8-result.md"
    pattern: "COMMIT_HASH: [a-f0-9]+"
    description: "Structural fixes committed"
    condition: "sheet_num >= 8"

  # Sheet 9: Summary
  - type: file_exists
    path: "{workspace}/09-evolution-summary.md"
    description: "Evolution summary exists"
    condition: "sheet_num >= 9"

  - type: content_regex
    path: "{workspace}/sheet9-result.md"
    pattern: "EVOLUTION_COMPLETE: yes"
    description: "Evolution marked complete"
    condition: "sheet_num >= 9"

  # ═══════════════════════════════════════════════════════════════════════════
  # GLOBAL VALIDATIONS
  # ═══════════════════════════════════════════════════════════════════════════

  - type: file_exists
    path: "{workspace}/sheet{sheet_num}-result.md"
    description: "Sheet result file exists"

  - type: content_contains
    path: "{workspace}/sheet{sheet_num}-result.md"
    pattern: "IMPLEMENTATION_COMPLETE: yes"
    description: "Sheet marked complete"

  - type: command_succeeds
    description: "No import errors after changes"
    command: cd /home/emzi/Projects/mozart-ai-compose && .venv/bin/python -c "from mozart.cli import app; from mozart.execution.runner import JobRunner"
    condition: "sheet_num >= 7"

  - type: command_succeeds
    description: "Tests still pass after changes"
    # Note: Ignoring test_runner.py due to hanging tests (TestRunnerReturnsRunSummary)
    command: cd /home/emzi/Projects/mozart-ai-compose && .venv/bin/python -m pytest tests/ -q --tb=no --ignore=tests/test_runner.py 2>&1 | tail -3 | grep -qE "passed|no tests"
    condition: "sheet_num >= 7"

  # NOTE: Commit validation deferred - requires worktree isolation for parallel safety
  # The prompts for sheets 7-9 include explicit commit instructions in PHASE 4

learning:
  enabled: true

cost_limits:
  enabled: false
