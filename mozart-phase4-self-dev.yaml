# Mozart Phase 4 Self-Development: Judgment Integration
# Mozart consults Recursive Light for judgment on retry/escalate decisions

name: "mozart-phase4-judgment"
description: "Mozart implements judgment integration with Recursive Light"

workspace: "./self-dev-workspace"

backend:
  type: claude_cli
  skip_permissions: true
  working_directory: "/home/emzi/Projects/mozart-ai-compose"
  timeout_seconds: 1800

batch:
  size: 1
  total_items: 2  # 2 Phase 4 tasks
  start_item: 1

prompt:
  template: |
    Let's begin a new session. Begin by using the session start skill.
    Embody the TDF in all decisions at every turn throughout this session.

    You are implementing Mozart's Phase 4 (Judgment Integration).
    Phases 1-3 are COMPLETE. Mozart can now connect to Recursive Light.

    STEP 1: READ SKILL FILES:
    {% for skill in skill_files %}
    - {{ skill }}
    {% endfor %}

    STEP 2: READ PROJECT CONTEXT:
    {% for ctx in context_files %}
    - {{ ctx }}
    {% endfor %}

    {% set task = tasks[batch_num - 1] %}
    CURRENT STATUS:
    - Working on Task {{ batch_num }} of {{ total_batches }}: {{ task.name }}

    STEP 3: READ REFERENCE FILES:
    {% for ref in task.reference_files %}
    - {{ ref }}
    {% endfor %}

    REQUIREMENTS:
    {{ task.requirements }}

    STEP 4: IMPLEMENT AND VALIDATE:
    ```bash
    cd /home/emzi/Projects/mozart-ai-compose
    source .venv/bin/activate
    pytest tests/ -v > {{ workspace }}/pytest-phase4.txt 2>&1
    mypy src/ > {{ workspace }}/mypy-phase4.txt 2>&1
    ruff check src/ > {{ workspace }}/ruff-phase4.txt 2>&1
    ```

    STEP 5: WRITE OUTPUT MARKERS to {{ workspace }}/phase4-task{{ batch_num }}-result.txt:
    - TASK_NAME: {{ task.name }}
    - FILES_CREATED: [list paths]
    - FILES_MODIFIED: [list paths]
    - TESTS_PASS: yes/no
    - TYPES_PASS: yes/no
    - LINT_PASS: yes/no
    - IMPLEMENTATION_COMPLETE: yes/no

    {{ stakes }}
    {{ thinking_method }}

  variables:
    skill_files:
      - /home/emzi/.claude/skills/session-startup-protocol.md
      - /home/emzi/.claude/skills/tetrahedral-decision-framework.md
    context_files:
      - STATUS.md
      - memory-bank/activeContext.md
    tasks:
      - name: "Create JudgmentClient for Recursive Light"
        requirements: |
          Create: src/mozart/learning/judgment.py

          Implement:
          1. JudgmentQuery dataclass:
             - job_id: str
             - batch_num: int
             - validation_results: list[dict]
             - execution_history: list[dict]
             - error_patterns: list[str]
             - retry_count: int
             - confidence: float
             - similar_outcomes: list[dict]

          2. JudgmentResponse dataclass:
             - recommended_action: Literal["proceed", "retry", "completion", "escalate", "abort"]
             - confidence: float
             - reasoning: str
             - prompt_modifications: Optional[list[str]] = None
             - escalation_urgency: Optional[Literal["low", "medium", "high"]] = None
             - human_question: Optional[str] = None
             - patterns_learned: list[str] = field(default_factory=list)

          3. JudgmentClient class:
             - __init__(endpoint: str, timeout: float = 30.0)
             - async get_judgment(query: JudgmentQuery) -> JudgmentResponse
               POST to {endpoint}/api/mozart/judgment
               Handle errors gracefully (return default "retry" action)

          4. LocalJudgmentClient class (fallback when RL unavailable):
             - Uses simple heuristics based on confidence/pass_rate
             - No network calls, always available
        reference_files:
          - src/mozart/learning/outcomes.py
          - src/mozart/execution/escalation.py
          - src/mozart/backends/recursive_light.py

      - name: "Integrate JudgmentClient into JobRunner"
        requirements: |
          Modify: src/mozart/execution/runner.py

          Add judgment_client parameter to __init__:
          - judgment_client: Optional[JudgmentClient] = None

          Add new method _decide_with_judgment():
          ```python
          async def _decide_with_judgment(
              self,
              batch_num: int,
              validation_result: BatchValidationResult,
              execution_history: list[ExecutionResult],
          ) -> BatchExecutionMode:
          ```

          Logic:
          - If judgment_client is None, fall back to _decide_next_action()
          - Build JudgmentQuery from current state
          - Call judgment_client.get_judgment(query)
          - Log any patterns_learned from response
          - Map JudgmentResponse.recommended_action to BatchExecutionMode
          - Handle prompt_modifications if provided

          Update _execute_batch_with_recovery():
          - Track execution_history (list of ExecutionResult from attempts)
          - Use _decide_with_judgment() instead of _decide_next_action()

          Update learning/__init__.py:
          - Export JudgmentQuery, JudgmentResponse, JudgmentClient, LocalJudgmentClient
        reference_files:
          - src/mozart/execution/runner.py
          - src/mozart/learning/judgment.py
          - src/mozart/execution/escalation.py

  stakes: |
    STAKES:
    - Complete implementation with passing tests = 1T$ tip
    - Incomplete, failing tests, or missing markers = fed to wolves

  thinking_method: |
    Apply TDF domains:
    - COMP: Protocol design, async patterns, fallback logic
    - SCI: Test judgment responses, validate decision mapping
    - CULT: Integrate with existing escalation patterns
    - EXP: Design for graceful degradation

validations:
  - type: file_exists
    path: "{workspace}/phase4-task{batch_num}-result.txt"
    description: "Task result file created"

  - type: content_contains
    path: "{workspace}/phase4-task{batch_num}-result.txt"
    pattern: "IMPLEMENTATION_COMPLETE: yes"
    description: "Task marked as complete"

  - type: content_contains
    path: "{workspace}/phase4-task{batch_num}-result.txt"
    pattern: "TESTS_PASS: yes"
    description: "Tests pass"

  - type: content_contains
    path: "{workspace}/phase4-task{batch_num}-result.txt"
    pattern: "TYPES_PASS: yes"
    description: "Type checking passes"

retry:
  max_retries: 3
  max_completion_attempts: 2
  completion_threshold_percent: 50.0
  base_delay_seconds: 10

rate_limit:
  wait_minutes: 60
  max_waits: 10

state_backend: json
pause_between_batches_seconds: 5
