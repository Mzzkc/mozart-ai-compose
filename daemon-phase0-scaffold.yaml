# ╔══════════════════════════════════════════════════════════════════════════════╗
# ║              DAEMON SYMPHONY: PHASE 0 — ARCHITECTURE & SCAFFOLD            ║
# ║                                                                            ║
# ║  Foundation phase. Extracts service abstractions from CLI layer without    ║
# ║  breaking ANYTHING. Creates `src/mozart/daemon/` package with:             ║
# ║    - DaemonConfig (Pydantic v2)                                            ║
# ║    - OutputProtocol (replaces Rich console coupling)                       ║
# ║    - JobService (execution logic extracted from CLI)                       ║
# ║                                                                            ║
# ║  Execution Flow (9 stages → 11 sheets after fan-out):                     ║
# ║                                                                            ║
# ║    [1] Discovery → [2] Scaffold → [3] Output Protocol →                   ║
# ║    [4] JobService → [5] Tests → [6] Completion Pass →                     ║
# ║        [7a] [7b] [7c]  ← Code Reviews (PARALLEL) →                        ║
# ║    [8] Apply Fixes → [9] Commit                                           ║
# ║                                                                            ║
# ║  Chains to: daemon-phase1-ipc.yaml                                        ║
# ║                                                                            ║
# ║  Usage:                                                                    ║
# ║    cd /home/emzi/Projects/mozart-ai-compose                                ║
# ║    setsid mozart run daemon-phase0-scaffold.yaml \                         ║
# ║      > .daemon-workspace-p0/mozart.log 2>&1 &                             ║
# ║    mozart status daemon-phase0-scaffold -w .daemon-workspace-p0 --watch    ║
# ╚══════════════════════════════════════════════════════════════════════════════╝

name: "daemon-phase0-scaffold"
description: "Extract daemon service abstractions — OutputProtocol, JobService, DaemonConfig"

workspace: "./.daemon-workspace-p0"

workspace_lifecycle:
  archive_on_fresh: true
  max_archives: 5

backend:
  type: claude_cli
  skip_permissions: true
  working_directory: /home/emzi/Projects/mozart-ai-compose
  timeout_seconds: 2400

cross_sheet:
  auto_capture_stdout: true
  max_output_chars: 3000
  lookback_sheets: 2
  capture_files:
    - "{{ workspace }}/*.md"

sheet:
  size: 1
  total_items: 9

  fan_out:
    7: 3  # Code review: Architecture, Tests, Backwards Compat

  dependencies:
    2: [1]
    3: [2]
    4: [3]
    5: [4]
    6: [5]
    7: [6]
    8: [7]
    9: [8]

parallel:
  enabled: true
  max_concurrent: 3

retry:
  max_retries: 2

on_success:
  - type: run_job
    job_path: "daemon-phase1-ipc.yaml"
    job_workspace: ".daemon-workspace-p1"
    description: "Chain to Phase 1: IPC Layer"
    detached: true

concert:
  enabled: true
  max_chain_depth: 5
  cooldown_between_jobs_seconds: 30

prompt:
  template: |
    {{ preamble }}

    **Sheet:** {{ sheet_num }} of {{ total_sheets }} | **Stage:** {{ stage }}
    **Workspace:** {{ workspace }}

    {% if stage == 1 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 1: DISCOVERY & ARCHITECTURE DESIGN                                   ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    **The preamble already created the daemon-symphony branch. Push it to origin:**
    ```bash
    git push -u origin daemon-symphony
    ```

    Analyze the codebase to design the daemon architecture. This is the blueprint
    for the entire Daemon Symphony concert (5 phases, ~57 sheets total).

    **Read these files carefully:**
    - `src/mozart/backends/base.py` — Backend protocol (98% daemon-ready)
    - `src/mozart/state/base.py` — StateBackend protocol
    - `src/mozart/execution/runner/__init__.py` — JobRunner mixin composition
    - `src/mozart/execution/runner/models.py` — RunnerContext, RunSummary
    - `src/mozart/cli/commands/run.py` — The _run_job() function we'll extract
    - `src/mozart/cli/commands/resume.py` — Resume logic to extract
    - `src/mozart/cli/commands/pause.py` — Pause logic to extract
    - `src/mozart/cli/helpers.py` — Backend/notifier creation utilities
    - `src/mozart/dashboard/services/job_control.py` — Dashboard's existing job control
    - `src/mozart/dashboard/app.py` — FastAPI app factory pattern to reuse

    **Architecture Requirements:**

    1. **DaemonConfig** (Pydantic v2):
       - socket_path: Path (default: /tmp/mozartd.sock)
       - pid_file: Path (default: /tmp/mozartd.pid)
       - max_concurrent_jobs: int (default: 5)
       - max_concurrent_sheets: int (default: 10)
       - resource_limits: ResourceLimitConfig (max_memory_mb, max_processes)
       - state_backend_type: Literal["json", "sqlite"] (default: "sqlite")
       - log config

    2. **OutputProtocol** (ABC replacing Rich console):
       - log(level, message, **context)
       - progress(job_id, completed, total, eta_seconds)
       - sheet_event(job_id, sheet_num, event_type, data)
       - job_event(job_id, event_type, data)
       - Implementations: NullOutput, StructuredOutput, ConsoleOutput

    3. **JobService** (extracted from CLI):
       - async start_job(config, fresh, self_healing, dry_run) -> RunSummary
       - async resume_job(job_id, workspace, ...) -> RunSummary
       - async pause_job(job_id, workspace) -> bool
       - async get_status(job_id, workspace) -> CheckpointState | None
       - Backend/notifier creation as private methods

    4. **Backwards Compatibility** (NON-NEGOTIABLE):
       - `mozart run` MUST work identically to today
       - New code goes in `src/mozart/daemon/` ONLY
       - CLI modifications are wiring-only, no behavior changes

    **Write architecture design to:** `{{ workspace }}/01-architecture.md`

    Include: package layout, class diagrams, data flow, migration risks.
    End with: `ARCHITECTURE_COMPLETE: yes`

    {% elif stage == 2 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 2: CREATE DAEMON PACKAGE SCAFFOLD                                    ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Create the daemon package based on the architecture from Stage 1.

    {% if previous_outputs and 1 in previous_outputs %}
    **Stage 1 architecture summary:**
    {{ previous_outputs[1][:2000] }}
    {% endif %}

    **Create these files:**

    1. **`src/mozart/daemon/__init__.py`** — Package init with exports:
       ```python
       """Mozart daemon service — long-running orchestration (mozartd)."""
       from mozart.daemon.config import DaemonConfig
       from mozart.daemon.types import DaemonStatus, JobRequest, JobResponse
       ```

    2. **`src/mozart/daemon/config.py`** — Pydantic v2 models:
       Follow the Field() pattern from `src/mozart/core/config.py`.
       ```python
       class ResourceLimitConfig(BaseModel):
           max_memory_mb: int = Field(default=8192, ge=512)
           max_processes: int = Field(default=50, ge=5)
           max_api_calls_per_minute: int = Field(default=60, ge=1)

       class SocketConfig(BaseModel):
           path: Path = Field(default=Path("/tmp/mozartd.sock"))
           permissions: int = Field(default=0o660)
           backlog: int = Field(default=5, ge=1)

       class DaemonConfig(BaseModel):
           socket: SocketConfig = Field(default_factory=SocketConfig)
           pid_file: Path = Field(default=Path("/tmp/mozartd.pid"))
           max_concurrent_jobs: int = Field(default=5, ge=1, le=50)
           max_concurrent_sheets: int = Field(default=10, ge=1, le=100)
           resource_limits: ResourceLimitConfig = Field(default_factory=ResourceLimitConfig)
           state_backend_type: Literal["json", "sqlite"] = "sqlite"
           state_db_path: Path = Field(default=Path("~/.mozart/daemon-state.db"))
           log_level: str = Field(default="info")
           log_file: Path | None = None
       ```

    3. **`src/mozart/daemon/types.py`** — Shared Pydantic types:
       ```python
       class JobRequest(BaseModel):
           config_path: Path
           workspace: Path | None = None
           fresh: bool = False
           self_healing: bool = False
           self_healing_auto_confirm: bool = False

       class JobResponse(BaseModel):
           job_id: str
           status: Literal["accepted", "rejected", "error"]
           message: str | None = None

       class DaemonStatus(BaseModel):
           pid: int
           uptime_seconds: float
           running_jobs: int
           total_sheets_active: int
           memory_usage_mb: float
           version: str
       ```

    4. **`src/mozart/daemon/exceptions.py`** — Exception hierarchy:
       ```python
       class DaemonError(Exception): """Base daemon exception."""
       class DaemonNotRunningError(DaemonError): ...
       class DaemonAlreadyRunningError(DaemonError): ...
       class JobSubmissionError(DaemonError): ...
       class ResourceExhaustedError(DaemonError): ...
       ```

    **Verify imports work:**
    ```bash
    cd /home/emzi/Projects/mozart-ai-compose
    python3 -c "from mozart.daemon.config import DaemonConfig; print(DaemonConfig()); print('OK')"
    ```

    **Output:** `{{ workspace }}/02-scaffold.md` — list all files created.
    End with: `SCAFFOLD_COMPLETE: yes`

    {% elif stage == 3 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 3: OUTPUT PROTOCOL                                                    ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Create the OutputProtocol abstraction replacing Rich console coupling.

    **Context:** Currently `RunnerContext` in `src/mozart/execution/runner/models.py`
    has `console: Console | None` and `progress_callback`. The daemon needs a
    protocol-based output that can be structured logging, SSE broadcast, or Rich.

    **Read first:** `src/mozart/execution/runner/models.py` — understand RunnerContext
    **Read first:** `src/mozart/cli/output.py` — understand current console usage

    **Create `src/mozart/daemon/output.py`:**

    ```python
    from __future__ import annotations
    from abc import ABC, abstractmethod
    from typing import Any

    class OutputProtocol(ABC):
        """Abstract output for job execution feedback.

        Replaces tight coupling to Rich Console. Implementations:
        - NullOutput: no-op for tests
        - StructuredOutput: structlog for daemon
        - ConsoleOutput: wraps Rich for CLI backwards compat
        """

        @abstractmethod
        def log(self, level: str, message: str, **context: Any) -> None: ...

        @abstractmethod
        def progress(
            self, job_id: str, completed: int, total: int,
            eta_seconds: float | None = None,
        ) -> None: ...

        @abstractmethod
        def sheet_event(
            self, job_id: str, sheet_num: int,
            event: str, data: dict[str, Any] | None = None,
        ) -> None: ...

        @abstractmethod
        def job_event(
            self, job_id: str, event: str,
            data: dict[str, Any] | None = None,
        ) -> None: ...


    class NullOutput(OutputProtocol):
        """No-op output for testing."""
        def log(self, level, message, **context): pass
        def progress(self, job_id, completed, total, eta_seconds=None): pass
        def sheet_event(self, job_id, sheet_num, event, data=None): pass
        def job_event(self, job_id, event, data=None): pass


    class StructuredOutput(OutputProtocol):
        """Structured logging output for daemon mode."""
        def __init__(self):
            from mozart.core.logging import get_logger
            self._logger = get_logger("daemon.output")

        def log(self, level, message, **context):
            getattr(self._logger, level, self._logger.info)(message, **context)

        def progress(self, job_id, completed, total, eta_seconds=None):
            self._logger.info("job.progress", job_id=job_id,
                            completed=completed, total=total,
                            eta_seconds=eta_seconds)

        def sheet_event(self, job_id, sheet_num, event, data=None):
            self._logger.info(f"sheet.{event}", job_id=job_id,
                            sheet_num=sheet_num, **(data or {}))

        def job_event(self, job_id, event, data=None):
            self._logger.info(f"job.{event}", job_id=job_id, **(data or {}))
    ```

    **Also create a ConsoleOutput** class that wraps Rich Console for CLI
    backwards compatibility. Read `src/mozart/cli/output.py` to understand
    what console operations the CLI uses, and provide equivalent methods.

    **DO NOT modify RunnerContext yet.** That wiring happens in Phase 2.
    This stage creates the protocol and all implementations only.

    **Verify:**
    ```bash
    python3 -c "
    from mozart.daemon.output import OutputProtocol, NullOutput, StructuredOutput
    n = NullOutput()
    n.log('info', 'test')
    n.progress('job1', 5, 10)
    print('OutputProtocol OK')
    "
    ```

    **Output:** `{{ workspace }}/03-output-protocol.md`
    End with: `OUTPUT_PROTOCOL_COMPLETE: yes`

    {% elif stage == 4 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 4: EXTRACT JOB SERVICE                                                ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Extract job execution logic from CLI into a reusable `JobService`.

    **Read these files CAREFULLY — they contain the logic to extract:**
    - `src/mozart/cli/commands/run.py` — find the async function that creates a
      Backend, StateBackend, RunnerContext, and calls runner.run()
    - `src/mozart/cli/commands/resume.py` — resume logic
    - `src/mozart/cli/commands/pause.py` — pause logic
    - `src/mozart/cli/helpers.py` — backend creation, notifier creation

    **Create `src/mozart/daemon/job_service.py`:**

    ```python
    """Core job execution service — decoupled from CLI.

    Extracted from CLI commands to enable both CLI and daemon usage.
    The CLI becomes a thin wrapper around this service.
    """

    from __future__ import annotations
    from pathlib import Path
    from typing import TYPE_CHECKING

    from mozart.daemon.output import NullOutput, OutputProtocol

    if TYPE_CHECKING:
        from mozart.backends.base import Backend
        from mozart.core.checkpoint import CheckpointState
        from mozart.core.config import BackendConfig, JobConfig
        from mozart.execution.runner.models import RunSummary
        from mozart.learning.global_store import GlobalLearningStore
        from mozart.notifications.base import NotificationManager
        from mozart.state.base import StateBackend


    class JobService:
        """Core job execution service.

        Encapsulates the logic from CLI run/resume/pause commands into
        a reusable service that can be called from CLI, daemon, dashboard,
        or MCP server.
        """

        def __init__(
            self,
            *,
            output: OutputProtocol | None = None,
            global_learning_store: GlobalLearningStore | None = None,
        ):
            self._output = output or NullOutput()
            self._learning_store = global_learning_store

        async def start_job(
            self,
            config: JobConfig,
            *,
            fresh: bool = False,
            self_healing: bool = False,
            self_healing_auto_confirm: bool = False,
            dry_run: bool = False,
        ) -> RunSummary:
            """Start a job from config."""
            # Extract from CLI run command:
            # 1. Create backend via _create_backend()
            # 2. Create state backend
            # 3. Create runner context
            # 4. Create JobRunner
            # 5. Call runner.run()
            ...

        async def resume_job(
            self,
            job_id: str,
            workspace: Path,
            *,
            reload_config: bool = False,
            config_path: Path | None = None,
        ) -> RunSummary:
            """Resume a paused or failed job."""
            ...

        async def pause_job(self, job_id: str, workspace: Path) -> bool:
            """Pause a running job via signal file."""
            ...

        async def get_status(
            self, job_id: str, workspace: Path,
        ) -> CheckpointState | None:
            """Get job status from state backend."""
            ...

        def _create_backend(self, config: BackendConfig) -> Backend:
            """Create execution backend from config."""
            # Extract from cli/helpers.py
            ...

        def _create_state_backend(
            self, workspace: Path, backend_type: str = "json",
        ) -> StateBackend:
            """Create state persistence backend."""
            ...
    ```

    **CRITICAL:** Do NOT modify any existing CLI commands. Only create the service.
    The extraction should mirror the CLI logic faithfully — same error handling,
    same backend creation, same runner configuration. Copy logic, don't redesign it.

    **Verify:**
    ```bash
    python3 -c "from mozart.daemon.job_service import JobService; print('OK')"
    ```

    **Output:** `{{ workspace }}/04-job-service.md` listing:
    - Methods and their signatures
    - What CLI logic was extracted
    - What remains CLI-only (Rich formatting, Typer options)
    End with: `JOB_SERVICE_COMPLETE: yes`

    {% elif stage == 5 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 5: UNIT TESTS                                                         ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Write comprehensive unit tests for all daemon package components.

    **Create these test files:**

    1. **`tests/test_daemon_config.py`**
       - Test DaemonConfig default values
       - Test DaemonConfig validation (invalid ranges, paths)
       - Test ResourceLimitConfig boundaries
       - Test SocketConfig defaults
       - Test from_yaml if implemented

    2. **`tests/test_daemon_output.py`**
       - Test NullOutput methods don't raise
       - Test StructuredOutput logs via structlog (mock get_logger)
       - Test ConsoleOutput wraps Rich correctly
       - Test OutputProtocol is abstract (can't instantiate directly)

    3. **`tests/test_daemon_job_service.py`**
       - Test JobService instantiation
       - Test start_job with mocked Backend (use MemoryStateBackend)
       - Test pause_job creates signal file
       - Test get_status returns state
       - Test _create_backend for each backend type

    **Follow existing test patterns:**
    ```bash
    # Look at existing tests for patterns
    head -50 tests/test_config.py
    head -50 tests/test_runner.py
    ```

    **Run tests:**
    ```bash
    cd /home/emzi/Projects/mozart-ai-compose
    source .venv/bin/activate
    pytest tests/test_daemon_config.py tests/test_daemon_output.py tests/test_daemon_job_service.py -v
    ```

    Fix any failures. Do NOT skip or xfail tests.

    **Output:** `{{ workspace }}/05-tests.md`
    End with: `TESTS_COMPLETE: yes`

    {% elif stage == 6 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 6: COMPLETION PASS                                                    ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Verify ALL work from stages 1-5 is complete and correct.

    **Checklist (run ALL of these):**

    ```bash
    cd /home/emzi/Projects/mozart-ai-compose
    source .venv/bin/activate

    # 1. All daemon files exist
    ls -la src/mozart/daemon/__init__.py
    ls -la src/mozart/daemon/config.py
    ls -la src/mozart/daemon/types.py
    ls -la src/mozart/daemon/exceptions.py
    ls -la src/mozart/daemon/output.py
    ls -la src/mozart/daemon/job_service.py

    # 2. All test files exist
    ls -la tests/test_daemon_config.py
    ls -la tests/test_daemon_output.py
    ls -la tests/test_daemon_job_service.py

    # 3. New daemon tests pass
    pytest tests/test_daemon_*.py -v

    # 4. ALL existing tests still pass
    pytest tests/ -x --timeout=180 -q

    # 5. Lint clean
    ruff check src/mozart/daemon/

    # 6. Imports work
    python3 -c "from mozart.daemon import DaemonConfig, DaemonStatus; print('OK')"
    python3 -c "from mozart.daemon.output import OutputProtocol, NullOutput; print('OK')"
    python3 -c "from mozart.daemon.job_service import JobService; print('OK')"
    ```

    **Fix ANY issues.** If existing tests fail, that's a backwards compat problem —
    investigate the root cause and fix it. The daemon package must be invisible to
    existing code.

    **Output:** `{{ workspace }}/06-completion.md`
    End with: `COMPLETION_PASS_COMPLETE: yes`

    {% elif stage == 7 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 7: CODE REVIEW ({{ instance }} of {{ fan_count }})                    ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    {% if instance == 1 %}
    **REVIEWER: Architecture Quality**

    Review all `src/mozart/daemon/` files for:
    1. **Protocol consistency** — Does OutputProtocol follow Backend/StateBackend patterns?
    2. **Pydantic patterns** — Do config models match `src/mozart/core/config.py` style?
    3. **Import hygiene** — No circular imports, TYPE_CHECKING where needed
    4. **Abstraction leaks** — Does JobService expose CLI-specific concepts?
    5. **Error handling** — Proper exception hierarchy, no bare except
    6. **Naming** — Follows project conventions

    Read each file in `src/mozart/daemon/`. Grade A/B/C/D for:
    - Architecture, Protocol Design, Code Quality

    List specific issues with file:line references and suggested fixes.

    {% elif instance == 2 %}
    **REVIEWER: Test Coverage**

    Review all `tests/test_daemon_*.py` files for:
    1. **Coverage** — All public methods tested?
    2. **Edge cases** — Validation errors, None, empty configs, boundary values
    3. **Mock quality** — Testing behavior, not implementation details
    4. **Fixture quality** — Appropriate pytest fixtures, not duplicate setup
    5. **Assertion quality** — Specific assertions, not just "no exception"

    Grade A/B/C/D for: Coverage, Edge Cases, Mock Quality.
    List specific missing tests.

    {% elif instance == 3 %}
    **REVIEWER: Backwards Compatibility**

    Verify ZERO existing behavior has changed:

    ```bash
    cd /home/emzi/Projects/mozart-ai-compose
    source .venv/bin/activate

    # Import compatibility
    python3 -c "from mozart.execution.runner import JobRunner, RunSummary; print('OK')"
    python3 -c "from mozart.backends.base import Backend, ExecutionResult; print('OK')"
    python3 -c "from mozart.state.base import StateBackend; print('OK')"
    python3 -c "from mozart.core.config import JobConfig; print('OK')"
    python3 -c "from mozart.cli import app; print('OK')"

    # Full test suite
    pytest tests/ -x --timeout=180 -q --ignore=tests/test_daemon_*.py
    ```

    Grade PASS/FAIL for: Import Compat, CLI Compat, Test Suite.
    If ANYTHING fails, that is a CRITICAL issue — document exactly what broke.
    {% endif %}

    **Output:** `{{ workspace }}/07-review-{{ instance }}.md`
    End with: `REVIEW_COMPLETE: yes`

    {% elif stage == 8 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 8: APPLY REVIEW FIXES                                                 ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Read all three code review reports and apply fixes:

    ```bash
    cat {{ workspace }}/07-review-1.md
    cat {{ workspace }}/07-review-2.md
    cat {{ workspace }}/07-review-3.md
    ```

    **Apply fixes for issues graded B or lower.** Focus on:
    - CRITICAL: Backwards compatibility problems
    - HIGH: Protocol design issues, missing critical tests
    - MEDIUM: Code quality, missing edge case tests
    - Skip: Cosmetic suggestions, style preferences

    After fixing, verify:
    ```bash
    pytest tests/test_daemon_*.py -v
    pytest tests/ -x --timeout=180 -q
    ruff check src/mozart/daemon/
    ```

    **Output:** `{{ workspace }}/08-fixes.md`
    End with: `FIXES_APPLIED: yes`

    {% elif stage == 9 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 9: FINAL TESTS + COMMIT                                               ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    **Step 1: Full verification**
    ```bash
    cd /home/emzi/Projects/mozart-ai-compose
    source .venv/bin/activate
    pytest tests/ -x --timeout=180 -q
    ruff check src/mozart/daemon/
    ```

    **Step 2: Selective git commit**
    Stage ONLY daemon-related files:
    ```bash
    git add src/mozart/daemon/__init__.py
    git add src/mozart/daemon/config.py
    git add src/mozart/daemon/types.py
    git add src/mozart/daemon/exceptions.py
    git add src/mozart/daemon/output.py
    git add src/mozart/daemon/job_service.py
    git add tests/test_daemon_config.py
    git add tests/test_daemon_output.py
    git add tests/test_daemon_job_service.py

    git status

    git commit -m "feat(daemon): Phase 0 — scaffold daemon package with service abstractions

    Create src/mozart/daemon/ package with foundational abstractions for
    the mozartd daemon service (issue #39):

    - DaemonConfig: Pydantic v2 config for socket, resources, limits
    - OutputProtocol: Abstract output replacing Rich console coupling
    - JobService: Core execution logic extracted from CLI commands
    - Exception hierarchy for daemon-specific errors
    - Comprehensive unit tests for all components

    Part of the Daemon Symphony concert (Phase 0 of 4).

    Co-Authored-By: Mozart AI Compose <noreply@anthropic.com>"
    ```

    **Step 3: Push**
    ```bash
    git push -u origin daemon-symphony
    ```

    **Output:** `{{ workspace }}/09-commit.md`
    End with: `COMMIT_COMPLETE: yes`
    {% endif %}

    {{ output_footer }}

  variables:
    preamble: |
      ╔══════════════════════════════════════════════════════════════════════════════╗
      ║  DAEMON SYMPHONY: PHASE 0 — Architecture & Scaffold                        ║
      ║  Part of the Mozart Daemon Migration Concert (Issue #39)                    ║
      ╚══════════════════════════════════════════════════════════════════════════════╝

      **Context:** You are executing one sheet of a 5-phase concert that transforms
      Mozart from a CLI-per-job tool into a long-running daemon service (mozartd).
      This is Phase 0: creating the foundational abstractions.

      **Project:** Mozart AI Compose at /home/emzi/Projects/mozart-ai-compose

      **Phase 0 Goal:** Create `src/mozart/daemon/` package with clean abstractions.
      NO daemon process, NO IPC — just the service layer that everything builds on.

      **CRITICAL — Branch Protocol (do this FIRST, before any other work):**
      ```bash
      cd /home/emzi/Projects/mozart-ai-compose
      git checkout daemon-symphony 2>/dev/null || git checkout -b daemon-symphony
      ```
      All commits go to `daemon-symphony`, NEVER to `main`.
      NEVER use `git add .` or `git add -A`. Only stage specific source files listed in the instructions.
      NEVER commit workspace files (`.daemon-workspace-*`). They are gitignored artifacts.

      **Key Architecture Facts:**
      - 93% of codebase has ZERO CLI coupling (backends, state, execution, learning)
      - JobRunner is already fully async — runs in any event loop as-is
      - Protocol-based: Backend, StateBackend, Notifier are all abstract
      - Only `cli/` (7%) needs replacement for daemon mode
      - Existing dashboard uses FastAPI and SSE (reusable patterns)

      **Coding Standards:**
      - Async throughout — all I/O is async/await
      - Pydantic v2 with Field() for ALL config models
      - structlog for logging — never print()
      - Type hints on ALL functions
      - Follow patterns in existing codebase exactly

    output_footer: |
      ---
      **IMPORTANT:** Write your primary output to the specified workspace file.
      All source files you create must be syntactically correct and importable.
      Run any tests you write to confirm they pass before finishing.

      **LAST STEP — Return to main branch before this sheet ends:**
      ```bash
      cd /home/emzi/Projects/mozart-ai-compose
      git checkout main
      ```
      This keeps Mozart running from the stable main branch between sheets.

validations:
  - type: file_exists
    path: "{workspace}/01-architecture.md"
    condition: "sheet_num == 1"
    description: "Architecture design document"
  - type: content_contains
    path: "{workspace}/01-architecture.md"
    pattern: "ARCHITECTURE_COMPLETE"
    condition: "sheet_num == 1"

  - type: file_exists
    path: "{workspace}/02-scaffold.md"
    condition: "sheet_num == 2"
  - type: content_contains
    path: "{workspace}/02-scaffold.md"
    pattern: "SCAFFOLD_COMPLETE"
    condition: "sheet_num == 2"

  - type: file_exists
    path: "{workspace}/03-output-protocol.md"
    condition: "sheet_num == 3"
  - type: content_contains
    path: "{workspace}/03-output-protocol.md"
    pattern: "OUTPUT_PROTOCOL_COMPLETE"
    condition: "sheet_num == 3"

  - type: file_exists
    path: "{workspace}/04-job-service.md"
    condition: "sheet_num == 4"
  - type: content_contains
    path: "{workspace}/04-job-service.md"
    pattern: "JOB_SERVICE_COMPLETE"
    condition: "sheet_num == 4"

  - type: file_exists
    path: "{workspace}/05-tests.md"
    condition: "sheet_num == 5"
  - type: content_contains
    path: "{workspace}/05-tests.md"
    pattern: "TESTS_COMPLETE"
    condition: "sheet_num == 5"

  - type: file_exists
    path: "{workspace}/06-completion.md"
    condition: "sheet_num == 6"
  - type: content_contains
    path: "{workspace}/06-completion.md"
    pattern: "COMPLETION_PASS_COMPLETE"
    condition: "sheet_num == 6"

  - type: file_exists
    path: "{workspace}/07-review-1.md"
    condition: "sheet_num == 7"
  - type: file_exists
    path: "{workspace}/07-review-2.md"
    condition: "sheet_num == 8"
  - type: file_exists
    path: "{workspace}/07-review-3.md"
    condition: "sheet_num == 9"

  - type: file_exists
    path: "{workspace}/08-fixes.md"
    condition: "sheet_num == 10"
  - type: content_contains
    path: "{workspace}/08-fixes.md"
    pattern: "FIXES_APPLIED"
    condition: "sheet_num == 10"

  - type: file_exists
    path: "{workspace}/09-commit.md"
    condition: "sheet_num == 11"
  - type: content_contains
    path: "{workspace}/09-commit.md"
    pattern: "COMMIT_COMPLETE"
    condition: "sheet_num == 11"

  # ═══ HARD GATES: Imports + tests pass (on daemon-symphony branch) ═══
  - type: command_succeeds
    command: "cd /home/emzi/Projects/mozart-ai-compose && git checkout daemon-symphony -q && .venv/bin/python -c 'from mozart.daemon.config import DaemonConfig; from mozart.daemon.output import OutputProtocol, NullOutput; from mozart.daemon.job_service import JobService; print(\"OK\")' ; _r=$?; git checkout main -q; exit $_r"
    condition: "sheet_num == 6"
    description: "All daemon package imports succeed"
  - type: command_succeeds
    command: "cd /home/emzi/Projects/mozart-ai-compose && git checkout daemon-symphony -q && .venv/bin/pytest tests/test_daemon_config.py tests/test_daemon_output.py tests/test_daemon_job_service.py -q --tb=line --no-header 2>&1 | tail -1 | grep -qE '[0-9]+ passed' ; _r=$?; git checkout main -q; exit $_r"
    condition: "sheet_num == 6"
    description: "Daemon unit tests pass"

  # ═══ HARD GATES: Mozart canary on main (proves main is unbroken) ═══
  - type: command_succeeds
    command: "cd /home/emzi/Projects/mozart-ai-compose && git checkout main -q && .venv/bin/mozart validate examples/sheet-review.yaml --json 2>/dev/null; test $? -le 1"
    condition: "sheet_num == 11"
    description: "Mozart CLI canary — main branch still works"

  # ═══ HARD GATES: Full test suite on daemon-symphony ═══
  - type: command_succeeds
    command: "cd /home/emzi/Projects/mozart-ai-compose && git checkout daemon-symphony -q && .venv/bin/pytest tests/ -x --timeout=120 -q --tb=line --no-header 2>&1 | tail -1 | grep -qE '[0-9]+ passed' ; _r=$?; git checkout main -q; exit $_r"
    condition: "sheet_num == 11"
    description: "Full test suite passes on daemon-symphony"
