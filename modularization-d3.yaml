# ╔══════════════════════════════════════════════════════════════════════════════╗
# ║                    PHASE D3: MODULARIZE runner.py                            ║
# ║                                                                              ║
# ║  Split src/mozart/execution/runner.py (4615 LOC) into focused modules        ║
# ║  Chained from D2, chains to D4                                               ║
# ╚══════════════════════════════════════════════════════════════════════════════╝

name: "modularization-d3-runner"
description: "Split runner.py into focused modules with backward compatibility"

workspace: "/home/emzi/Projects/mozart-ai-compose/modularization-workspace-d3"

backend:
  type: claude_cli
  skip_permissions: true
  working_directory: "/home/emzi/Projects/mozart-ai-compose"
  timeout_seconds: 5400

cross_sheet:
  auto_capture_stdout: true
  max_output_chars: 2000
  lookback_sheets: 1

sheet:
  size: 1
  total_items: 10
  start_item: 1

retry:
  max_retries: 2

prompt:
  template: |
    {{ preamble }}

    {% if sheet_num == 1 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  SHEET 1: ANALYZE runner.py STRUCTURE                                        ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    **Task:** Analyze JobRunner class and plan modular split

    1. Read `src/mozart/execution/runner.py`
    2. Group methods by responsibility:
       - Models/exceptions/contexts
       - Initialization and properties
       - Main run lifecycle
       - Sheet execution
       - Pattern management
       - Decision making/judgment
       - Error recovery
       - Cost tracking
       - Isolation (worktree)
    3. Identify dependencies between groups

    Write analysis to {{ workspace }}/sheet1-analysis.md

    {% elif sheet_num == 2 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  SHEET 2: CREATE models.py - Data Models                                     ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    {% if previous_outputs %}
    Previous: {{ previous_outputs[1][:500] if 1 in previous_outputs else "" }}
    {% endif %}

    **Task:** Extract models, exceptions, and contexts

    Create `src/mozart/execution/runner_staging/models.py`:
    - RunSummary dataclass
    - RunnerContext dataclass
    - SheetExecutionMode enum
    - ErrorRecord, ExecutionResult (if local)
    - Any custom exceptions

    Write progress to {{ workspace }}/sheet2-models.md

    {% elif sheet_num == 3 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  SHEET 3: CREATE base.py - Core Initialization                               ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    {% if previous_outputs %}
    Previous: {{ previous_outputs[2][:500] if 2 in previous_outputs else "" }}
    {% endif %}

    **Task:** Extract JobRunner initialization

    Create `src/mozart/execution/runner_staging/base.py` with `JobRunnerBase`:
    - `__init__` method with all parameters
    - Property accessors
    - Signal handler setup/removal
    - Basic state management

    Write progress to {{ workspace }}/sheet3-base.md

    {% elif sheet_num == 4 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  SHEET 4: CREATE lifecycle.py - Run Lifecycle                                ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    {% if previous_outputs %}
    Previous: {{ previous_outputs[3][:500] if 3 in previous_outputs else "" }}
    {% endif %}

    **Task:** Extract main run methods

    Create `src/mozart/execution/runner_staging/lifecycle.py` with `LifecycleMixin`:
    - `run()` main method
    - `_run_sequential()`, `_run_parallel()`
    - State initialization
    - Completion handling

    Write progress to {{ workspace }}/sheet4-lifecycle.md

    {% elif sheet_num == 5 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  SHEET 5: CREATE sheet.py - Sheet Execution                                  ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    {% if previous_outputs %}
    Previous: {{ previous_outputs[4][:500] if 4 in previous_outputs else "" }}
    {% endif %}

    **Task:** Extract sheet execution logic

    Create `src/mozart/execution/runner_staging/sheet.py` with `SheetExecutionMixin`:
    - `_execute_sheet_with_recovery()` (largest method)
    - `_build_sheet_context()`
    - `_populate_cross_sheet_context()`
    - Validation integration

    Write progress to {{ workspace }}/sheet5-sheet.md

    {% elif sheet_num == 6 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  SHEET 6: CREATE patterns.py - Pattern Management                            ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    {% if previous_outputs %}
    Previous: {{ previous_outputs[5][:500] if 5 in previous_outputs else "" }}
    {% endif %}

    **Task:** Extract pattern-related methods

    Create `src/mozart/execution/runner_staging/patterns.py` with `PatternMixin`:
    - `_query_relevant_patterns()`
    - `_record_pattern_feedback()`
    - `_assess_pattern_impact()`
    - Pattern injection methods

    Write progress to {{ workspace }}/sheet6-patterns.md

    {% elif sheet_num == 7 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  SHEET 7: CREATE recovery.py - Error Recovery                                ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    {% if previous_outputs %}
    Previous: {{ previous_outputs[6][:500] if 6 in previous_outputs else "" }}
    {% endif %}

    **Task:** Extract error handling and recovery

    Create `src/mozart/execution/runner_staging/recovery.py` with `RecoveryMixin`:
    - Retry logic and delays
    - Rate limit handling
    - Error classification integration
    - Self-healing coordination

    Write progress to {{ workspace }}/sheet7-recovery.md

    {% elif sheet_num == 8 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  SHEET 8: CREATE cost.py + isolation.py                                      ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    {% if previous_outputs %}
    Previous: {{ previous_outputs[7][:500] if 7 in previous_outputs else "" }}
    {% endif %}

    **Task:** Extract cost tracking and isolation

    Create `src/mozart/execution/runner_staging/cost.py` with `CostMixin`:
    - Cost estimation and tracking
    - Token counting

    Create `src/mozart/execution/runner_staging/isolation.py` with `IsolationMixin`:
    - Worktree setup/cleanup
    - Working directory management

    Write progress to {{ workspace }}/sheet8-cost-isolation.md

    {% elif sheet_num == 9 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  SHEET 9: CREATE __init__.py IN STAGING                                      ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    {% if previous_outputs %}
    Previous: {{ previous_outputs[8][:500] if 8 in previous_outputs else "" }}
    {% endif %}

    **Task:** Create composed JobRunner in STAGING directory

    Create `src/mozart/execution/runner_staging/__init__.py`:
    - Import all mixins from `runner_staging.X` (NOT `runner.X`)
    - Compose JobRunner class with all mixins
    - Export RunSummary, JobRunner, etc.

    **IMPORTANT:** Create in `runner_staging/`, NOT `runner/`. The atomic swap happens in Sheet 10.

    Write progress to {{ workspace }}/sheet9-init.md

    {% elif sheet_num == 10 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  SHEET 10: ATOMIC SWAP + UPDATE IMPORTS + VERIFY                             ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    {% if previous_outputs %}
    Previous: {{ previous_outputs[9][:500] if 9 in previous_outputs else "" }}
    {% endif %}

    **Task:** Perform atomic swap and verify

    **CRITICAL: This sheet performs the atomic swap from staging to final.**

    Execute these commands IN ORDER:
    ```bash
    # 1. Atomic swap: staging → final
    mv src/mozart/execution/runner_staging src/mozart/execution/runner

    # 2. Rename original file to legacy
    mv src/mozart/execution/runner.py src/mozart/execution/runner_legacy.py
    ```

    Then create new `src/mozart/execution/runner.py` (re-export shim):
    ```python
    """JobRunner - re-exports from modular package."""
    from mozart.execution.runner import *  # noqa
    from mozart.execution.runner import JobRunner, RunSummary
    ```

    **After the swap, update __init__.py imports** from `runner_staging` to `runner`:
    - Change `from mozart.execution.runner_staging.X` → `from mozart.execution.runner.X`

    Verify imports work:
    ```bash
    python -c "from mozart.execution.runner import JobRunner, RunSummary; print('OK')"
    ```

    Write final status to {{ workspace }}/sheet10-final.md

    {% endif %}

  variables:
    preamble: |
      ╔══════════════════════════════════════════════════════════════════════════╗
      ║              MOZART MODULARIZATION D3: runner.py → runner/               ║
      ║                                                                          ║
      ║  Target: Split 4615 LOC file into focused modules                        ║
      ║  Pattern: Mixin composition for JobRunner class                          ║
      ╚══════════════════════════════════════════════════════════════════════════╝

      **Module Structure:**
      ```
      src/mozart/execution/runner_staging/
      ├── __init__.py      # Composed JobRunner
      ├── models.py        # RunSummary, contexts (~350 LOC)
      ├── base.py          # Initialization (~500 LOC)
      ├── lifecycle.py     # run() methods (~500 LOC)
      ├── sheet.py         # Sheet execution (~1200 LOC)
      ├── patterns.py      # Pattern management (~400 LOC)
      ├── recovery.py      # Error recovery (~500 LOC)
      ├── cost.py          # Cost tracking (~150 LOC)
      └── isolation.py     # Worktree isolation (~200 LOC)
      ```

validations:
  # Sheet 2: models.py created
  - type: file_exists
    path: "src/mozart/execution/runner_staging/models.py"
    description: "models.py module must exist"
    condition: "sheet_num >= 2 and sheet_num < 10"

  # Sheet 3: base.py created
  - type: file_exists
    path: "src/mozart/execution/runner_staging/base.py"
    description: "base.py module must exist"
    condition: "sheet_num >= 3 and sheet_num < 10"

  # Sheet 4: lifecycle.py created
  - type: file_exists
    path: "src/mozart/execution/runner_staging/lifecycle.py"
    description: "lifecycle.py module must exist"
    condition: "sheet_num >= 4 and sheet_num < 10"

  # Sheet 5: sheet.py created
  - type: file_exists
    path: "src/mozart/execution/runner_staging/sheet.py"
    description: "sheet.py module must exist"
    condition: "sheet_num >= 5 and sheet_num < 10"

  # Sheet 6: patterns.py created
  - type: file_exists
    path: "src/mozart/execution/runner_staging/patterns.py"
    description: "patterns.py module must exist"
    condition: "sheet_num >= 6 and sheet_num < 10"

  # Sheet 7: recovery.py created
  - type: file_exists
    path: "src/mozart/execution/runner_staging/recovery.py"
    description: "recovery.py module must exist"
    condition: "sheet_num >= 7 and sheet_num < 10"

  # Sheet 8: cost.py + isolation.py created
  - type: file_exists
    path: "src/mozart/execution/runner_staging/cost.py"
    description: "cost.py module must exist"
    condition: "sheet_num >= 8 and sheet_num < 10"

  - type: file_exists
    path: "src/mozart/execution/runner_staging/isolation.py"
    description: "isolation.py module must exist"
    condition: "sheet_num >= 8 and sheet_num < 10"

  # Sheet 9: __init__.py created in staging
  - type: file_exists
    path: "src/mozart/execution/runner_staging/__init__.py"
    description: "Package __init__.py must exist in staging"
    condition: "sheet_num == 9"

  # Sheet 10: After atomic swap, check final location
  - type: file_exists
    path: "src/mozart/execution/runner/__init__.py"
    description: "Package __init__.py must exist after swap"
    condition: "sheet_num == 10"

  # Sheet 10: imports work
  - type: command_succeeds
    command: "python -c 'from mozart.execution.runner import JobRunner, RunSummary; print(\"OK\")'"
    description: "JobRunner import must work"
    condition: "sheet_num == 10"

# Chain to D4 on success
on_success:
  - type: run_job
    job_path: "modularization-d4.yaml"
    description: "Chain to D4: cli.py modularization"
    detached: true  # Run independently to avoid 300s hook timeout

concert:
  enabled: true
  max_chain_depth: 10
  cooldown_between_jobs_seconds: 30
  inherit_workspace: false
