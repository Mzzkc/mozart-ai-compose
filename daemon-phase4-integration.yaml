# ╔══════════════════════════════════════════════════════════════════════════════╗
# ║              DAEMON SYMPHONY: PHASE 4 — INTEGRATION & POLISH               ║
# ║                                                                            ║
# ║  Final phase. Wires everything together: end-to-end tests, CLI backwards   ║
# ║  compat verification, dashboard+MCP integration, systemd service,         ║
# ║  documentation, and the final PR to close issue #39.                       ║
# ║                                                                            ║
# ║  Execution Flow (10 stages → 12 sheets after fan-out):                    ║
# ║                                                                            ║
# ║    [1] E2E Tests → [2] CLI Compat → [3] Dashboard Integration →           ║
# ║    [4] MCP Integration → [5] Systemd Service → [6] mozart config →        ║
# ║    [7] Documentation →                                                     ║
# ║        [8a] [8b] [8c]  ← Final Reviews (PARALLEL) →                       ║
# ║    [9] Apply Fixes → [10] Final Commit + PR                               ║
# ║                                                                            ║
# ║  Depends on: Phases 0-3 (all daemon components)                           ║
# ║  Terminal phase — no further chaining.                                     ║
# ╚══════════════════════════════════════════════════════════════════════════════╝

name: "daemon-phase4-integration"
description: "Integration — E2E tests, CLI compat, dashboard/MCP, systemd, docs, final PR"

workspace: "./.daemon-workspace-p4"

workspace_lifecycle:
  archive_on_fresh: true
  max_archives: 5

backend:
  type: claude_cli
  skip_permissions: true
  working_directory: /home/emzi/Projects/mozart-ai-compose
  timeout_seconds: 3000  # 50 min — E2E tests take longer

cross_sheet:
  auto_capture_stdout: true
  max_output_chars: 3000
  lookback_sheets: 2
  capture_files:
    - "{{ workspace }}/*.md"

sheet:
  size: 1
  total_items: 10

  fan_out:
    8: 3

  dependencies:
    2: [1]
    3: [2]
    4: [3]
    5: [4]
    6: [5]
    7: [6]
    8: [7]
    9: [8]
    10: [9]

parallel:
  enabled: true
  max_concurrent: 3

retry:
  max_retries: 2

# No on_success — this is the terminal phase

concert:
  enabled: true
  max_chain_depth: 5

prompt:
  template: |
    {{ preamble }}

    **Sheet:** {{ sheet_num }} of {{ total_sheets }} | **Stage:** {{ stage }}
    **Workspace:** {{ workspace }}

    {% if stage == 1 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 1: END-TO-END INTEGRATION TESTS                                       ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Create comprehensive E2E tests that exercise the full daemon lifecycle.

    **Create `tests/test_daemon_e2e.py`:**

    These tests should exercise the FULL stack: daemon start, submit job,
    monitor progress, job completes, daemon stop.

    ```python
    """End-to-end daemon integration tests.

    Start a real daemon (foreground mode), submit jobs through IPC client,
    and verify completion.
    """
    import asyncio
    import pytest
    from pathlib import Path

    from mozart.daemon.process import _run_daemon
    from mozart.daemon.config import DaemonConfig, SocketConfig
    from mozart.daemon.ipc.client import DaemonClient


    @pytest.fixture
    async def daemon(tmp_path):
        """Start a daemon in the background for testing."""
        socket_path = tmp_path / "test-mozartd.sock"
        pid_file = tmp_path / "test-mozartd.pid"

        config = DaemonConfig(
            socket=SocketConfig(path=socket_path),
            pid_file=pid_file,
            max_concurrent_jobs=2,
            max_concurrent_sheets=3,
        )

        # Start daemon as background task
        daemon_task = asyncio.create_task(_run_daemon(config))

        # Wait for socket to appear
        for _ in range(50):
            if socket_path.exists():
                break
            await asyncio.sleep(0.1)

        client = DaemonClient(socket_path)
        yield client, config

        # Shutdown
        await client._call("daemon.shutdown", {"graceful": False})
        await asyncio.wait_for(daemon_task, timeout=10)


    class TestDaemonLifecycle:
        async def test_daemon_starts_and_responds(self, daemon):
            client, config = daemon
            status = await client.status()
            assert status.pid > 0
            assert status.running_jobs == 0

        async def test_submit_job(self, daemon):
            client, config = daemon
            # Create a minimal job config
            ...

        async def test_concurrent_jobs(self, daemon):
            client, config = daemon
            # Submit multiple jobs and verify concurrency limit
            ...

        async def test_graceful_shutdown(self, daemon):
            client, config = daemon
            # Submit job, then graceful shutdown (waits for completion)
            ...
    ```

    **Also create a simple test job config:**
    Create `tests/fixtures/test-daemon-job.yaml` — a minimal 1-sheet job.

    **Run E2E tests:**
    ```bash
    pytest tests/test_daemon_e2e.py -v --timeout=120
    ```

    **Output:** `{{ workspace }}/01-e2e-tests.md`
    End with: `E2E_TESTS_COMPLETE: yes`

    {% elif stage == 2 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 2: CLI BACKWARDS COMPATIBILITY VERIFICATION                           ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Systematically verify that ALL 23 existing CLI commands work unchanged.

    **Test each command category:**

    ```bash
    cd /home/emzi/Projects/mozart-ai-compose
    source .venv/bin/activate

    # === JOB EXECUTION ===
    echo "--- Testing: mozart run (dry-run) ---"
    mozart run examples/sheet-review.yaml --dry-run 2>&1 | head -20 || echo "FAIL"

    echo "--- Testing: mozart validate ---"
    mozart validate examples/sheet-review.yaml 2>&1 | head -20 || echo "FAIL"

    # === STATUS & INFO ===
    echo "--- Testing: mozart list ---"
    mozart list 2>&1 | head -10 || echo "FAIL"

    echo "--- Testing: mozart --help ---"
    mozart --help 2>&1 | head -20 || echo "FAIL"

    # === LEARNING COMMANDS ===
    echo "--- Testing: mozart learning-stats ---"
    mozart learning-stats 2>&1 | head -10 || echo "FAIL"

    echo "--- Testing: mozart patterns-list ---"
    mozart patterns-list 2>&1 | head -10 || echo "FAIL"

    echo "--- Testing: mozart patterns-entropy ---"
    mozart patterns-entropy 2>&1 | head -10 || echo "FAIL"
    ```

    **Verify the daemon auto-detection doesn't interfere:**
    - When daemon is NOT running, all commands must work exactly as before
    - No extra output, no errors, no latency penalty
    - The 2-second socket check timeout must not slow down commands

    **Run FULL test suite:**
    ```bash
    pytest tests/ -x --timeout=180 -q
    ```

    Record PASS/FAIL for each of the 23 commands.

    **Output:** `{{ workspace }}/02-cli-compat.md`
    End with: `CLI_COMPAT_COMPLETE: yes`

    {% elif stage == 3 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 3: DASHBOARD INTEGRATION                                              ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Wire the dashboard to use the daemon when available.

    **Read first:**
    - `src/mozart/dashboard/services/job_control.py` — Currently spawns subprocesses
    - `src/mozart/dashboard/routes/jobs.py` — Job CRUD routes
    - `src/mozart/dashboard/app.py` — App factory

    **Modify `src/mozart/dashboard/services/job_control.py`:**

    Currently `JobControlService.start_job()` spawns a subprocess. Add
    daemon-aware routing:
    ```python
    async def start_job(self, config_path, workspace, ...):
        # Try daemon first
        client = DaemonClient()
        if await client.is_daemon_running():
            response = await client.submit_job(JobRequest(
                config_path=config_path, workspace=workspace,
            ))
            return JobStartResult(
                job_id=response.job_id, via_daemon=True,
            )

        # Fallback to subprocess (existing behavior)
        ...
    ```

    **Same for pause, resume, cancel, status, list.**

    The dashboard should show a "Daemon Connected" indicator when mozartd runs.

    **Verify dashboard still works without daemon:**
    ```bash
    python3 -c "from mozart.dashboard.app import create_app; app = create_app(); print('OK')"
    ```

    **Output:** `{{ workspace }}/03-dashboard.md`
    End with: `DASHBOARD_INTEGRATION_COMPLETE: yes`

    {% elif stage == 4 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 4: MCP SERVER INTEGRATION                                             ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Wire the MCP server to use the daemon when available.

    **Read first:**
    - `src/mozart/mcp/server.py` — MCPServer
    - `src/mozart/mcp/tools.py` — MCP tool implementations

    **Modify MCP tools to route through daemon:**

    The MCP server's `JobTools` and `ControlTools` currently use subprocesses.
    Add daemon routing (same pattern as dashboard):

    ```python
    # In mcp/tools.py
    class JobTools:
        async def start_job(self, config_path, workspace=None):
            client = DaemonClient()
            if await client.is_daemon_running():
                response = await client.submit_job(...)
                return {"job_id": response.job_id, "via": "daemon"}
            # Existing subprocess approach
            ...
    ```

    **Verify MCP still works without daemon:**
    ```bash
    python3 -c "from mozart.mcp.server import MCPServer; s = MCPServer(); print('OK')"
    ```

    **Output:** `{{ workspace }}/04-mcp-integration.md`
    End with: `MCP_INTEGRATION_COMPLETE: yes`

    {% elif stage == 5 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 5: SYSTEMD SERVICE FILE                                               ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Create systemd service and installation scripts.

    **Create `scripts/mozartd.service`:**
    ```ini
    [Unit]
    Description=Mozart AI Compose Daemon
    After=network.target

    [Service]
    Type=notify
    ExecStart=/usr/local/bin/mozartd start --foreground
    ExecStop=/usr/local/bin/mozartd stop
    Restart=on-failure
    RestartSec=10
    User=%i
    Group=%i

    # Resource limits
    MemoryMax=8G
    TasksMax=100

    # Security hardening
    NoNewPrivileges=yes
    PrivateTmp=yes
    ProtectHome=read-only

    [Install]
    WantedBy=multi-user.target
    ```

    **Create `scripts/install-mozartd.sh`:**
    A bash script that:
    - Installs the Python package with daemon extras
    - Creates ~/.mozart config directory
    - Writes default mozartd.yaml config
    - Installs systemd user service
    - Enables the service

    **Also add `[project.optional-dependencies]` to `pyproject.toml`:**
    ```toml
    [project.optional-dependencies]
    daemon = ["psutil>=5.9"]
    ```

    **Output:** `{{ workspace }}/05-systemd.md`
    End with: `SYSTEMD_COMPLETE: yes`

    {% elif stage == 6 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 6: `mozart config` COMMAND                                            ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Add a `mozart config` command for daemon configuration.

    **Read first:**
    - `src/mozart/cli/__init__.py` — How commands are registered
    - `src/mozart/daemon/config.py` — DaemonConfig model

    **Create `src/mozart/cli/commands/config_cmd.py`:**

    Subcommands:
    - `mozart config show` — Display current config as table
    - `mozart config set <key> <value>` — Update a config value
    - `mozart config path` — Show config file location
    - `mozart config init` — Create default config file

    Use Rich Table for display, follow existing CLI command patterns.

    **Register in CLI's __init__.py.**

    **Output:** `{{ workspace }}/06-config-cmd.md`
    End with: `CONFIG_CMD_COMPLETE: yes`

    {% elif stage == 7 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 7: DOCUMENTATION                                                      ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Update project documentation for the daemon migration.

    **1. Update `CLAUDE.md`** — Add daemon section with:
    - Quick start (mozartd start/stop/status)
    - How CLI auto-detects daemon
    - Key daemon files table
    - Daemon debugging protocol

    **2. Update `STATUS.md`** — Add daemon completion status

    **3. Update `memory-bank/activeContext.md`** — Add daemon session notes

    **Do NOT create new markdown files** — only update existing ones.

    **Output:** `{{ workspace }}/07-documentation.md`
    End with: `DOCUMENTATION_COMPLETE: yes`

    {% elif stage == 8 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 8: FINAL CODE REVIEW ({{ instance }} of {{ fan_count }})              ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    {% if instance == 1 %}
    **REVIEWER: Full Architecture Review**

    Review the ENTIRE daemon package holistically:
    1. **Coherence** — Do all components work together cleanly?
    2. **Startup sequence** — Is daemon startup deterministic?
    3. **Shutdown sequence** — Is shutdown clean and complete?
    4. **Error paths** — What happens when things go wrong?
    5. **Configuration** — Is DaemonConfig sufficient?

    Read every file in `src/mozart/daemon/`. Grade A-D.

    {% elif instance == 2 %}
    **REVIEWER: Test Completeness**

    Review ALL daemon tests:
    1. **E2E coverage** — Does the suite prove the daemon works?
    2. **Unit coverage** — All modules independently tested?
    3. **Error scenarios** — Crash recovery, signals, resource exhaustion
    4. **Concurrency** — Race conditions, deadlocks tested
    5. **Backwards compat** — CLI regression tests exist

    ```bash
    pytest tests/test_daemon_*.py -v --tb=short
    ```

    {% elif instance == 3 %}
    **REVIEWER: Production Readiness**

    1. Security: socket permissions, PID file safety
    2. Observability: all critical paths logged with structlog
    3. Resource cleanup: no leaks on crash, shutdown, error
    4. Documentation: CLAUDE.md updated, inline docs complete
    5. Full test suite:
    ```bash
    pytest tests/ -x --timeout=180 -q
    ruff check src/
    ```
    {% endif %}

    **Output:** `{{ workspace }}/08-review-{{ instance }}.md`
    End with: `REVIEW_COMPLETE: yes`

    {% elif stage == 9 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 9: APPLY FINAL FIXES                                                  ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Read all three final reviews:
    ```bash
    cat {{ workspace }}/08-review-1.md
    cat {{ workspace }}/08-review-2.md
    cat {{ workspace }}/08-review-3.md
    ```

    Apply ALL fixes — this is the last chance before the PR.

    Verify EVERYTHING:
    ```bash
    pytest tests/ -x --timeout=180 -q
    ruff check src/
    pytest tests/test_daemon_*.py -v

    python3 -c "
    from mozart.daemon import DaemonConfig
    from mozart.daemon.ipc import DaemonServer, DaemonClient
    from mozart.daemon.manager import JobManager
    from mozart.daemon.scheduler import GlobalScheduler
    from mozart.daemon.monitor import ResourceMonitor
    from mozart.daemon.rate_coordinator import RateLimitCoordinator
    from mozart.daemon.backpressure import BackpressureController
    from mozart.daemon.learning_hub import LearningHub
    print('All daemon imports OK')
    "
    ```

    **Output:** `{{ workspace }}/09-final-fixes.md`
    End with: `FINAL_FIXES_COMPLETE: yes`

    {% elif stage == 10 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 10: FINAL COMMIT + PULL REQUEST                                       ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Create the final commit for the integration phase.

    **Step 1: Full verification**
    ```bash
    cd /home/emzi/Projects/mozart-ai-compose
    source .venv/bin/activate
    pytest tests/ --timeout=180 -q
    ruff check src/
    ```

    **Step 2: Stage ALL remaining daemon files**
    ```bash
    git add src/mozart/dashboard/services/job_control.py
    git add src/mozart/mcp/tools.py 2>/dev/null || true
    git add src/mozart/cli/commands/config_cmd.py 2>/dev/null || true
    git add src/mozart/cli/__init__.py
    git add scripts/mozartd.service 2>/dev/null || true
    git add scripts/install-mozartd.sh 2>/dev/null || true
    git add tests/test_daemon_e2e.py
    git add tests/fixtures/test-daemon-job.yaml 2>/dev/null || true
    git add CLAUDE.md
    git add STATUS.md
    git add memory-bank/activeContext.md
    git add pyproject.toml
    git add src/mozart/daemon/ 2>/dev/null || true

    git status
    ```

    **Step 3: Commit**
    ```bash
    git commit -m "feat(daemon): Phase 4 — integration, systemd, docs (completes #39)

    Final phase of the Daemon Symphony concert:

    - End-to-end integration tests for full daemon lifecycle
    - Dashboard routes through daemon when available
    - MCP server routes through daemon when available
    - systemd service file for production deployment
    - mozart config command for daemon configuration
    - Updated CLAUDE.md, STATUS.md with daemon documentation
    - All 23 CLI commands verified backwards-compatible

    Closes #39

    Co-Authored-By: Mozart AI Compose <noreply@anthropic.com>"
    ```

    **Step 4: Push to daemon-symphony and create PR**
    DO NOT push to main. Create a pull request for human review.
    ```bash
    git push -u origin daemon-symphony

    gh pr create \
      --title "feat(daemon): mozartd daemon service (closes #39)" \
      --base main \
      --head daemon-symphony \
      --body "## Summary

    Daemon Symphony concert complete. Transforms Mozart from CLI-per-job to
    long-running daemon service (mozartd).

    **Phase 0:** Service abstractions — DaemonConfig, OutputProtocol, JobService
    **Phase 1:** IPC layer — Unix socket + JSON-RPC 2.0
    **Phase 2:** Daemon process — mozartd, JobManager, ResourceMonitor
    **Phase 3:** Intelligence — GlobalScheduler, RateLimitCoordinator, Backpressure
    **Phase 4:** Integration — E2E tests, dashboard/MCP wiring, systemd, docs

    ## Test plan
    - [ ] All daemon unit tests pass (pytest tests/test_daemon_*.py)
    - [ ] Full existing test suite passes (pytest tests/ -x)
    - [ ] CLI backwards compatibility verified (all 23 commands)
    - [ ] mozartd start --foreground works
    - [ ] mozart run auto-detects daemon when running
    - [ ] Dashboard routes through daemon
    - [ ] Graceful shutdown cleans up all children (fixes #38)

    Closes #39"
    ```

    **Step 5: Completion summary**
    Write to `{{ workspace }}/10-final-commit.md`:
    - Total files created across all 5 phases
    - Total tests added
    - Commit hashes for all phase commits
    - Architecture summary

    End with: `DAEMON_SYMPHONY_COMPLETE: yes`
    {% endif %}

    {{ output_footer }}

  variables:
    preamble: |
      ╔══════════════════════════════════════════════════════════════════════════════╗
      ║  DAEMON SYMPHONY: PHASE 4 — Integration & Polish (FINAL)                    ║
      ║  Part of the Mozart Daemon Migration Concert (Issue #39)                    ║
      ╚══════════════════════════════════════════════════════════════════════════════╝

      **Context:** Final phase (4 of 5). Phases 0-3 built all daemon components.
      This phase wires everything together and closes issue #39.

      **Project:** Mozart AI Compose at /home/emzi/Projects/mozart-ai-compose

      **CRITICAL — Branch Protocol (do this FIRST, before any other work):**
      ```bash
      cd /home/emzi/Projects/mozart-ai-compose
      git checkout daemon-symphony
      ```
      All commits go to `daemon-symphony`, NEVER to `main`.
      This is the FINAL phase. The last stage creates a PR to merge to main.

      **Phase 4 Goal:** Integration testing, CLI backwards compat, dashboard/MCP
      wiring, systemd service, documentation, and the final commit.

      **Full daemon package now exists:**
      - `src/mozart/daemon/config.py` — DaemonConfig
      - `src/mozart/daemon/types.py` — JobRequest, JobResponse, DaemonStatus
      - `src/mozart/daemon/output.py` — OutputProtocol implementations
      - `src/mozart/daemon/job_service.py` — Core execution service
      - `src/mozart/daemon/ipc/` — Unix socket + client + JSON-RPC
      - `src/mozart/daemon/process.py` — mozartd entry point
      - `src/mozart/daemon/manager.py` — JobManager
      - `src/mozart/daemon/monitor.py` — ResourceMonitor
      - `src/mozart/daemon/pgroup.py` — Process group management
      - `src/mozart/daemon/scheduler.py` — Cross-job scheduler
      - `src/mozart/daemon/rate_coordinator.py` — Rate limit coordination
      - `src/mozart/daemon/backpressure.py` — Load management
      - `src/mozart/daemon/learning_hub.py` — Centralized learning

      **Coding Standards:**
      - Same as all previous phases
      - Integration tests use real daemon (foreground mode)
      - CLI changes must be zero-impact when daemon absent

    output_footer: |
      ---
      Write output to specified workspace file. All source files must be
      syntactically correct and importable. Run tests to verify.
      This is the FINAL PHASE — quality is paramount.

      **LAST STEP — Return to main branch before this sheet ends:**
      ```bash
      cd /home/emzi/Projects/mozart-ai-compose
      git checkout main
      ```
      This keeps Mozart running from the stable main branch between sheets.

validations:
  - type: file_exists
    path: "{workspace}/01-e2e-tests.md"
    condition: "sheet_num == 1"
  - type: content_contains
    path: "{workspace}/01-e2e-tests.md"
    pattern: "E2E_TESTS_COMPLETE"
    condition: "sheet_num == 1"

  - type: file_exists
    path: "{workspace}/02-cli-compat.md"
    condition: "sheet_num == 2"
  - type: content_contains
    path: "{workspace}/02-cli-compat.md"
    pattern: "CLI_COMPAT_COMPLETE"
    condition: "sheet_num == 2"

  - type: file_exists
    path: "{workspace}/03-dashboard.md"
    condition: "sheet_num == 3"
  - type: content_contains
    path: "{workspace}/03-dashboard.md"
    pattern: "DASHBOARD_INTEGRATION_COMPLETE"
    condition: "sheet_num == 3"

  - type: file_exists
    path: "{workspace}/04-mcp-integration.md"
    condition: "sheet_num == 4"
  - type: content_contains
    path: "{workspace}/04-mcp-integration.md"
    pattern: "MCP_INTEGRATION_COMPLETE"
    condition: "sheet_num == 4"

  - type: file_exists
    path: "{workspace}/05-systemd.md"
    condition: "sheet_num == 5"
  - type: content_contains
    path: "{workspace}/05-systemd.md"
    pattern: "SYSTEMD_COMPLETE"
    condition: "sheet_num == 5"

  - type: file_exists
    path: "{workspace}/06-config-cmd.md"
    condition: "sheet_num == 6"
  - type: content_contains
    path: "{workspace}/06-config-cmd.md"
    pattern: "CONFIG_CMD_COMPLETE"
    condition: "sheet_num == 6"

  - type: file_exists
    path: "{workspace}/07-documentation.md"
    condition: "sheet_num == 7"
  - type: content_contains
    path: "{workspace}/07-documentation.md"
    pattern: "DOCUMENTATION_COMPLETE"
    condition: "sheet_num == 7"

  - type: file_exists
    path: "{workspace}/08-review-1.md"
    condition: "sheet_num == 8"
  - type: file_exists
    path: "{workspace}/08-review-2.md"
    condition: "sheet_num == 9"
  - type: file_exists
    path: "{workspace}/08-review-3.md"
    condition: "sheet_num == 10"

  - type: file_exists
    path: "{workspace}/09-final-fixes.md"
    condition: "sheet_num == 11"
  - type: content_contains
    path: "{workspace}/09-final-fixes.md"
    pattern: "FINAL_FIXES_COMPLETE"
    condition: "sheet_num == 11"

  - type: file_exists
    path: "{workspace}/10-final-commit.md"
    condition: "sheet_num == 12"
  - type: content_contains
    path: "{workspace}/10-final-commit.md"
    pattern: "DAEMON_SYMPHONY_COMPLETE"
    condition: "sheet_num == 12"

  # ═══ HARD GATES: E2E + full suite on daemon-symphony ═══
  - type: command_succeeds
    command: "cd /home/emzi/Projects/mozart-ai-compose && git checkout daemon-symphony -q && .venv/bin/pytest tests/test_daemon_e2e.py -q --tb=line --no-header --timeout=120 2>&1 | tail -1 | grep -qE '[0-9]+ passed' ; _r=$?; git checkout main -q; exit $_r"
    condition: "sheet_num == 2"
    description: "E2E integration tests pass"
  - type: command_succeeds
    command: "cd /home/emzi/Projects/mozart-ai-compose && git checkout daemon-symphony -q && .venv/bin/pytest tests/ -x --timeout=120 -q --tb=line --no-header 2>&1 | tail -1 | grep -qE '[0-9]+ passed' ; _r=$?; git checkout main -q; exit $_r"
    condition: "sheet_num == 2"
    description: "Full test suite passes on daemon-symphony after E2E"

  # ═══ HARD GATES: All daemon imports on daemon-symphony ═══
  - type: command_succeeds
    command: "cd /home/emzi/Projects/mozart-ai-compose && git checkout daemon-symphony -q && .venv/bin/python -c 'from mozart.daemon import DaemonConfig; from mozart.daemon.ipc import DaemonServer, DaemonClient; from mozart.daemon.manager import JobManager; from mozart.daemon.scheduler import GlobalScheduler; from mozart.daemon.monitor import ResourceMonitor; from mozart.daemon.rate_coordinator import RateLimitCoordinator; from mozart.daemon.backpressure import BackpressureController; from mozart.daemon.learning_hub import LearningHub; print(\"OK\")' ; _r=$?; git checkout main -q; exit $_r"
    condition: "sheet_num == 12"
    description: "All daemon imports succeed"

  # ═══ HARD GATES: Mozart canary on main ═══
  - type: command_succeeds
    command: "cd /home/emzi/Projects/mozart-ai-compose && git checkout main -q && .venv/bin/mozart validate examples/sheet-review.yaml --json 2>/dev/null; test $? -le 1"
    condition: "sheet_num == 12"
    description: "Mozart CLI canary — main branch still works"

  # ═══ HARD GATES: Final full suite on daemon-symphony ═══
  - type: command_succeeds
    command: "cd /home/emzi/Projects/mozart-ai-compose && git checkout daemon-symphony -q && .venv/bin/pytest tests/ -x --timeout=120 -q --tb=line --no-header 2>&1 | tail -1 | grep -qE '[0-9]+ passed' ; _r=$?; git checkout main -q; exit $_r"
    condition: "sheet_num == 12"
    description: "Final full test suite gate on daemon-symphony"
