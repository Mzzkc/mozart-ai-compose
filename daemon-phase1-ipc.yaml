# ╔══════════════════════════════════════════════════════════════════════════════╗
# ║              DAEMON SYMPHONY: PHASE 1 — IPC LAYER                          ║
# ║                                                                            ║
# ║  Communication layer: Unix domain socket server with JSON-RPC 2.0         ║
# ║  protocol. CLI auto-detects running daemon and routes accordingly.         ║
# ║  When no daemon → falls back to direct execution (100% backwards compat). ║
# ║                                                                            ║
# ║  Execution Flow (9 stages → 11 sheets after fan-out):                     ║
# ║                                                                            ║
# ║    [1] Protocol Design → [2] Socket Server → [3] Client Library →         ║
# ║    [4] JSON-RPC Models → [5] CLI Auto-Detection → [6] Tests →             ║
# ║        [7a] [7b] [7c]  ← Code Reviews (PARALLEL) →                        ║
# ║    [8] Apply Fixes → [9] Commit                                           ║
# ║                                                                            ║
# ║  Depends on: Phase 0 (daemon/ package, OutputProtocol, JobService)        ║
# ║  Chains to: daemon-phase2-service.yaml                                    ║
# ╚══════════════════════════════════════════════════════════════════════════════╝

name: "daemon-phase1-ipc"
description: "IPC layer — Unix socket server, JSON-RPC 2.0 protocol, client library, CLI auto-detection"

workspace: "./.daemon-workspace-p1"

workspace_lifecycle:
  archive_on_fresh: true
  max_archives: 5

backend:
  type: claude_cli
  skip_permissions: true
  working_directory: /home/emzi/Projects/mozart-ai-compose
  timeout_seconds: 2400

cross_sheet:
  auto_capture_stdout: true
  max_output_chars: 3000
  lookback_sheets: 2
  capture_files:
    - "{{ workspace }}/*.md"

sheet:
  size: 1
  total_items: 9

  fan_out:
    7: 3

  dependencies:
    2: [1]
    3: [2]
    4: [3]
    5: [4]
    6: [5]
    7: [6]
    8: [7]
    9: [8]

parallel:
  enabled: true
  max_concurrent: 3

retry:
  max_retries: 2

on_success:
  - type: run_job
    job_path: "daemon-phase2-service.yaml"
    description: "Chain to Phase 2: Daemon Service"
    detached: true

concert:
  enabled: true
  max_chain_depth: 5
  cooldown_between_jobs_seconds: 30

prompt:
  template: |
    {{ preamble }}

    **Sheet:** {{ sheet_num }} of {{ total_sheets }} | **Stage:** {{ stage }}
    **Workspace:** {{ workspace }}

    {% if stage == 1 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 1: IPC PROTOCOL DESIGN                                                ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Design the IPC protocol for daemon ↔ CLI communication.

    **Study existing patterns:**
    - `src/mozart/dashboard/app.py` — FastAPI app factory (similar HTTP patterns)
    - `src/mozart/mcp/server.py` — MCP JSON-RPC server (our JSON-RPC reference)
    - `src/mozart/dashboard/services/sse_manager.py` — SSE streaming (for log streaming)
    - `src/mozart/daemon/types.py` — Already-created types from Phase 0

    **Protocol Choice: JSON-RPC 2.0 over Unix Domain Socket**

    Rationale:
    - Unix socket: local-only, filesystem permissions, no TCP overhead
    - JSON-RPC: standard, simple, matches MCP server pattern
    - Async: asyncio.start_unix_server / open_unix_connection

    **Define all RPC methods:**

    | Method | Params | Returns | Description |
    |--------|--------|---------|-------------|
    | `daemon.status` | none | DaemonStatus | Daemon health/metrics |
    | `daemon.shutdown` | `{graceful: bool}` | bool | Stop daemon |
    | `job.submit` | JobRequest | JobResponse | Submit new job |
    | `job.status` | `{job_id, workspace}` | CheckpointState | Job status |
    | `job.pause` | `{job_id, workspace}` | bool | Pause job |
    | `job.resume` | `{job_id, workspace}` | JobResponse | Resume job |
    | `job.cancel` | `{job_id, workspace}` | bool | Cancel job |
    | `job.list` | `{workspace?}` | list[JobSummary] | List all jobs |
    | `job.logs` | `{job_id, workspace, follow}` | StreamRef | Log streaming |

    **Error codes** (JSON-RPC standard + Mozart extensions):
    - -32700: Parse error
    - -32600: Invalid request
    - -32601: Method not found
    - -32602: Invalid params
    - -32603: Internal error
    - -32000: Job not found
    - -32001: Resource exhausted
    - -32002: Job already running
    - -32003: Daemon shutting down

    **Connection lifecycle:**
    ```
    Client connects to Unix socket
    → Sends JSON-RPC request (newline-delimited JSON)
    → Server routes to handler
    → Server sends JSON-RPC response
    → Connection stays open for streaming (job.logs)
    → Client disconnects when done
    ```

    **Output:** `{{ workspace }}/01-ipc-design.md`
    End with: `IPC_DESIGN_COMPLETE: yes`

    {% elif stage == 2 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 2: UNIX SOCKET SERVER                                                 ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Create the async Unix domain socket server.

    {% if previous_outputs and 1 in previous_outputs %}
    **Stage 1 protocol design:**
    {{ previous_outputs[1][:2000] }}
    {% endif %}

    **Create `src/mozart/daemon/ipc/__init__.py`:**
    ```python
    """IPC layer for mozartd — Unix socket + JSON-RPC 2.0."""
    from mozart.daemon.ipc.server import DaemonServer
    from mozart.daemon.ipc.client import DaemonClient
    ```

    **Create `src/mozart/daemon/ipc/server.py`:**

    The server should:
    1. Create Unix domain socket at configured path
    2. Accept concurrent client connections (asyncio.start_unix_server)
    3. Read newline-delimited JSON-RPC requests
    4. Route to registered handler methods
    5. Send JSON-RPC responses
    6. Handle connection errors gracefully
    7. Clean up socket file on shutdown

    ```python
    class DaemonServer:
        """Async Unix domain socket server with JSON-RPC 2.0 routing."""

        def __init__(self, socket_path: Path, handler: RequestHandler):
            self._socket_path = socket_path
            self._handler = handler
            self._server: asyncio.Server | None = None

        async def start(self) -> None:
            """Start listening on Unix socket."""
            # Remove stale socket file if exists
            self._socket_path.unlink(missing_ok=True)
            self._server = await asyncio.start_unix_server(
                self._handle_connection, path=str(self._socket_path),
            )
            os.chmod(self._socket_path, 0o660)

        async def stop(self) -> None:
            """Stop server and clean up socket."""
            if self._server:
                self._server.close()
                await self._server.wait_closed()
            self._socket_path.unlink(missing_ok=True)

        async def _handle_connection(
            self, reader: asyncio.StreamReader, writer: asyncio.StreamWriter,
        ) -> None:
            """Handle a single client connection."""
            try:
                while True:
                    line = await reader.readline()
                    if not line:
                        break  # Client disconnected
                    request = json.loads(line)
                    response = await self._handler.handle(request)
                    writer.write(json.dumps(response).encode() + b"\n")
                    await writer.drain()
            except (ConnectionResetError, json.JSONDecodeError) as e:
                logger.warning("connection_error", error=str(e))
            finally:
                writer.close()
                await writer.wait_closed()
    ```

    **Also create `src/mozart/daemon/ipc/handler.py`:**

    ```python
    class RequestHandler:
        """Routes JSON-RPC requests to method handlers."""

        def __init__(self):
            self._methods: dict[str, Callable] = {}

        def register(self, method: str, handler: Callable) -> None:
            self._methods[method] = handler

        async def handle(self, request: dict) -> dict:
            """Process a JSON-RPC 2.0 request and return response."""
            ...
    ```

    **Verify:**
    ```bash
    python3 -c "from mozart.daemon.ipc.server import DaemonServer; print('OK')"
    ```

    **Output:** `{{ workspace }}/02-server.md`
    End with: `SERVER_COMPLETE: yes`

    {% elif stage == 3 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 3: CLIENT LIBRARY                                                     ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Create the async client that CLI uses to talk to the daemon.

    **Create `src/mozart/daemon/ipc/client.py`:**

    The client should:
    1. Connect to Unix socket at configured path
    2. Send JSON-RPC requests and receive responses
    3. Provide typed methods for each daemon operation
    4. Include `is_daemon_running()` check (tries to connect)
    5. Handle connection failures gracefully
    6. Support connection timeout

    ```python
    class DaemonClient:
        """Async client for communicating with mozartd."""

        def __init__(self, socket_path: Path | None = None):
            self._socket_path = socket_path or Path("/tmp/mozartd.sock")

        async def is_daemon_running(self) -> bool:
            """Check if daemon is running by attempting socket connection."""
            try:
                reader, writer = await asyncio.wait_for(
                    asyncio.open_unix_connection(str(self._socket_path)),
                    timeout=2.0,
                )
                writer.close()
                await writer.wait_closed()
                return True
            except (ConnectionRefusedError, FileNotFoundError, asyncio.TimeoutError):
                return False

        async def _call(self, method: str, params: dict | None = None) -> Any:
            """Send JSON-RPC request and return result."""
            reader, writer = await asyncio.open_unix_connection(
                str(self._socket_path),
            )
            try:
                request = {
                    "jsonrpc": "2.0",
                    "method": method,
                    "params": params or {},
                    "id": str(uuid.uuid4()),
                }
                writer.write(json.dumps(request).encode() + b"\n")
                await writer.drain()

                line = await asyncio.wait_for(reader.readline(), timeout=30.0)
                response = json.loads(line)
                if "error" in response:
                    raise DaemonError(response["error"]["message"])
                return response.get("result")
            finally:
                writer.close()
                await writer.wait_closed()

        async def status(self) -> DaemonStatus:
            """Get daemon status."""
            result = await self._call("daemon.status")
            return DaemonStatus(**result)

        async def submit_job(self, request: JobRequest) -> JobResponse:
            """Submit a job to the daemon."""
            result = await self._call("job.submit", request.model_dump(mode="json"))
            return JobResponse(**result)

        async def get_job_status(self, job_id: str, workspace: str) -> dict:
            """Get job status."""
            return await self._call("job.status", {"job_id": job_id, "workspace": workspace})

        async def pause_job(self, job_id: str, workspace: str) -> bool:
            return await self._call("job.pause", {"job_id": job_id, "workspace": workspace})

        async def list_jobs(self) -> list[dict]:
            return await self._call("job.list")
    ```

    **Verify:**
    ```bash
    python3 -c "from mozart.daemon.ipc.client import DaemonClient; c = DaemonClient(); print('OK')"
    ```

    **Output:** `{{ workspace }}/03-client.md`
    End with: `CLIENT_COMPLETE: yes`

    {% elif stage == 4 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 4: JSON-RPC PROTOCOL MODELS                                           ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Create the Pydantic models for JSON-RPC 2.0 protocol messages.

    **Create `src/mozart/daemon/ipc/protocol.py`:**

    ```python
    """JSON-RPC 2.0 protocol models for daemon IPC."""
    from __future__ import annotations
    from typing import Any
    from pydantic import BaseModel, Field

    # Standard JSON-RPC 2.0 error codes
    PARSE_ERROR = -32700
    INVALID_REQUEST = -32600
    METHOD_NOT_FOUND = -32601
    INVALID_PARAMS = -32602
    INTERNAL_ERROR = -32603

    # Mozart daemon extension error codes
    JOB_NOT_FOUND = -32000
    RESOURCE_EXHAUSTED = -32001
    JOB_ALREADY_RUNNING = -32002
    DAEMON_SHUTTING_DOWN = -32003


    class JsonRpcRequest(BaseModel):
        jsonrpc: str = Field(default="2.0", pattern=r"^2\.0$")
        method: str
        params: dict[str, Any] = Field(default_factory=dict)
        id: str | int | None = None

    class JsonRpcError(BaseModel):
        code: int
        message: str
        data: Any = None

    class JsonRpcResponse(BaseModel):
        jsonrpc: str = "2.0"
        result: Any = None
        error: JsonRpcError | None = None
        id: str | int | None = None

        @classmethod
        def success(cls, result: Any, request_id: str | int | None) -> JsonRpcResponse:
            return cls(result=result, id=request_id)

        @classmethod
        def error_response(
            cls, code: int, message: str,
            request_id: str | int | None = None, data: Any = None,
        ) -> JsonRpcResponse:
            return cls(error=JsonRpcError(code=code, message=message, data=data),
                      id=request_id)
    ```

    **Verify:**
    ```bash
    python3 -c "
    from mozart.daemon.ipc.protocol import JsonRpcRequest, JsonRpcResponse
    req = JsonRpcRequest(method='daemon.status', id='1')
    resp = JsonRpcResponse.success({'pid': 123}, '1')
    print(req.model_dump_json())
    print(resp.model_dump_json())
    print('OK')
    "
    ```

    **Output:** `{{ workspace }}/04-protocol.md`
    End with: `PROTOCOL_MODELS_COMPLETE: yes`

    {% elif stage == 5 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 5: DAEMON DETECTION MODULE (NEW FILE ONLY — NO EXISTING CHANGES)      ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Create the daemon detection/routing module as a NEW file. This module will be
    wired into the CLI in Phase 4. We do NOT modify any existing files here because
    Mozart is using itself to run this concert — breaking the CLI kills the chain.

    **Read first (to understand what the routing module needs to wrap):**
    - `src/mozart/cli/commands/run.py` — the run command we'll route in Phase 4
    - `src/mozart/cli/commands/status.py` — status/list commands
    - `src/mozart/cli/commands/pause.py` — pause command

    **Create `src/mozart/daemon/detect.py`:**

    ```python
    """Daemon detection and CLI routing — safe fallback to direct execution.

    This module is used by CLI commands to auto-detect a running mozartd
    daemon and route operations through it. When no daemon is detected,
    the caller falls back to direct execution (existing behavior).

    SAFETY: Every public function catches ALL exceptions and returns a
    "not routed" result. This ensures that daemon bugs never break the CLI.
    The CLI wiring (Phase 4) wraps calls in try/except as a second layer.
    """
    from __future__ import annotations

    from pathlib import Path
    from typing import Any

    from mozart.core.logging import get_logger

    _logger = get_logger("daemon.detect")


    async def is_daemon_available(socket_path: Path | None = None) -> bool:
        """Check if mozartd is running. Safe: returns False on any error."""
        try:
            from mozart.daemon.ipc.client import DaemonClient
            client = DaemonClient(socket_path)
            return await client.is_daemon_running()
        except Exception:
            return False


    async def try_daemon_route(
        method: str, params: dict[str, Any], *,
        socket_path: Path | None = None,
    ) -> tuple[bool, Any]:
        """Try routing a CLI command through the daemon.

        Returns:
            (True, result) if daemon handled the request.
            (False, None) if daemon is not running or any error occurred.

        This function NEVER raises — any exception returns (False, None).
        """
        try:
            from mozart.daemon.ipc.client import DaemonClient
            client = DaemonClient(socket_path)
            if not await client.is_daemon_running():
                return False, None
            result = await client._call(method, params)
            return True, result
        except Exception as e:
            _logger.debug("daemon_route_failed", method=method, error=str(e))
            return False, None
    ```

    **DO NOT MODIFY any existing CLI files.** The wiring happens in Phase 4
    (the terminal phase) where existing-file modifications can't break the
    concert chain.

    **Verify the new module is importable (no side effects):**
    ```bash
    python3 -c "from mozart.daemon.detect import try_daemon_route, is_daemon_available; print('OK')"
    ```

    **Output:** `{{ workspace }}/05-detect-module.md`
    End with: `DETECT_MODULE_COMPLETE: yes`

    {% elif stage == 6 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 6: TESTS                                                              ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Write comprehensive tests for the IPC layer.

    **Create these test files:**

    1. **`tests/test_daemon_ipc_protocol.py`**
       - Test JsonRpcRequest/Response serialization
       - Test error response factory methods
       - Test request validation (missing method, bad jsonrpc version)
       - Test all error codes are defined

    2. **`tests/test_daemon_ipc_server.py`**
       - Test DaemonServer start/stop lifecycle
       - Test socket file creation and cleanup
       - Test RequestHandler routing
       - Test concurrent client handling
       - Test malformed request handling
       - Use real Unix socket (tmp dir) — NOT mocks

    3. **`tests/test_daemon_ipc_client.py`**
       - Test is_daemon_running() returns False when no daemon
       - Test DaemonClient connect/disconnect
       - Test all typed methods (status, submit_job, etc.)
       - Test connection timeout handling
       - Test against real DaemonServer (integration test)

    4. **`tests/test_daemon_cli_detection.py`**
       - Test CLI fallback when daemon not running
       - Test CLI routes through daemon when running
       - Test error handling in daemon detection

    **Run all tests:**
    ```bash
    pytest tests/test_daemon_ipc_*.py tests/test_daemon_cli_detection.py -v
    pytest tests/ -x --timeout=180 -q  # Verify nothing broke
    ```

    **Output:** `{{ workspace }}/06-tests.md`
    End with: `TESTS_COMPLETE: yes`

    {% elif stage == 7 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 7: CODE REVIEW ({{ instance }} of {{ fan_count }})                    ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    {% if instance == 1 %}
    **REVIEWER: IPC Architecture**

    Review `src/mozart/daemon/ipc/` for:
    1. **Socket security** — Permissions (0o660), path validation, no symlink attacks
    2. **Protocol correctness** — JSON-RPC 2.0 compliance, error code usage
    3. **Connection handling** — Concurrent clients, cleanup on error, resource leaks
    4. **Message framing** — Newline-delimited JSON robustness, max message size
    5. **Shutdown sequence** — Graceful shutdown, in-flight request handling

    Grade A/B/C/D for: Security, Protocol, Robustness.
    List issues with file:line references.

    {% elif instance == 2 %}
    **REVIEWER: Test Quality**

    Review all IPC test files for:
    1. **Integration tests** — Do tests use real Unix sockets, not just mocks?
    2. **Edge cases** — Connection refused, timeout, malformed JSON, huge payloads
    3. **Cleanup** — Socket files cleaned up after tests
    4. **Race conditions** — Concurrent client tests properly synchronized
    5. **Coverage** — Every RPC method has both success and error test

    Grade A/B/C/D for: Coverage, Robustness, Cleanup.

    {% elif instance == 3 %}
    **REVIEWER: Backwards Compatibility**

    Verify CLI changes are truly non-breaking:
    ```bash
    cd /home/emzi/Projects/mozart-ai-compose
    source .venv/bin/activate

    # Core imports unchanged
    python3 -c "from mozart.cli import app; print('OK')"
    python3 -c "from mozart.execution.runner import JobRunner; print('OK')"

    # CLI dry-run still works (no daemon needed)
    mozart validate examples/sheet-review.yaml

    # Full test suite
    pytest tests/ -x --timeout=180 -q
    ```

    Grade PASS/FAIL for each check. ANY failure is CRITICAL.
    {% endif %}

    **Output:** `{{ workspace }}/07-review-{{ instance }}.md`
    End with: `REVIEW_COMPLETE: yes`

    {% elif stage == 8 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 8: APPLY REVIEW FIXES                                                 ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Read all three review reports and apply HIGH/CRITICAL fixes:
    ```bash
    cat {{ workspace }}/07-review-1.md
    cat {{ workspace }}/07-review-2.md
    cat {{ workspace }}/07-review-3.md
    ```

    Focus on: security issues, protocol bugs, missing cleanup, backwards compat.
    Skip: style preferences, cosmetic changes.

    After fixing, verify:
    ```bash
    pytest tests/test_daemon_ipc_*.py tests/test_daemon_cli_detection.py -v
    pytest tests/ -x --timeout=180 -q
    ruff check src/mozart/daemon/ipc/
    ```

    **Output:** `{{ workspace }}/08-fixes.md`
    End with: `FIXES_APPLIED: yes`

    {% elif stage == 9 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  STAGE 9: COMMIT                                                             ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    **Step 1: Final verification**
    ```bash
    cd /home/emzi/Projects/mozart-ai-compose
    source .venv/bin/activate
    pytest tests/ -x --timeout=180 -q
    ruff check src/mozart/daemon/
    ```

    **Step 2: Selective git commit**
    ```bash
    git add src/mozart/daemon/ipc/__init__.py
    git add src/mozart/daemon/ipc/server.py
    git add src/mozart/daemon/ipc/client.py
    git add src/mozart/daemon/ipc/handler.py
    git add src/mozart/daemon/ipc/protocol.py
    git add src/mozart/daemon/detect.py
    # Add test files
    git add tests/test_daemon_ipc_*.py
    git add tests/test_daemon_cli_detection.py

    git status

    git commit -m "feat(daemon): Phase 1 — IPC layer with Unix socket + JSON-RPC 2.0

    Add communication infrastructure for mozartd (issue #39):

    - DaemonServer: async Unix domain socket server
    - DaemonClient: typed async client with connection management
    - JSON-RPC 2.0 protocol models with Mozart error extensions
    - RequestHandler: method routing with error handling
    - CLI auto-detection: routes to daemon if running, falls back otherwise
    - Comprehensive IPC tests with real socket integration

    Part of the Daemon Symphony concert (Phase 1 of 4).

    Co-Authored-By: Mozart AI Compose <noreply@anthropic.com>"
    ```

    **Step 3: Push**
    ```bash
    git push -u origin daemon-symphony
    ```

    **Output:** `{{ workspace }}/09-commit.md`
    End with: `COMMIT_COMPLETE: yes`
    {% endif %}

    {{ output_footer }}

  variables:
    preamble: |
      ╔══════════════════════════════════════════════════════════════════════════════╗
      ║  DAEMON SYMPHONY: PHASE 1 — IPC Layer                                      ║
      ║  Part of the Mozart Daemon Migration Concert (Issue #39)                    ║
      ╚══════════════════════════════════════════════════════════════════════════════╝

      **Context:** Phase 1 of 5 in the Daemon Symphony concert. Phase 0 created
      the daemon/ package scaffold (DaemonConfig, OutputProtocol, JobService).
      This phase adds the IPC communication layer.

      **Project:** Mozart AI Compose at /home/emzi/Projects/mozart-ai-compose

      **CRITICAL — Branch Protocol (do this FIRST, before any other work):**
      ```bash
      cd /home/emzi/Projects/mozart-ai-compose
      git checkout daemon-symphony
      ```
      All commits go to `daemon-symphony`, NEVER to `main`.
      NEVER use `git add .` or `git add -A`. Only stage specific source files listed in the instructions.
      NEVER commit workspace files (`.daemon-workspace-*`). They are gitignored artifacts.

      **Phase 1 Goal:** Build the IPC layer (Unix socket + JSON-RPC 2.0) that
      CLI uses to communicate with the daemon. No daemon process yet (Phase 2).

      **Already exists from Phase 0:**
      - `src/mozart/daemon/config.py` — DaemonConfig with SocketConfig
      - `src/mozart/daemon/types.py` — JobRequest, JobResponse, DaemonStatus
      - `src/mozart/daemon/exceptions.py` — DaemonError hierarchy
      - `src/mozart/daemon/output.py` — OutputProtocol implementations
      - `src/mozart/daemon/job_service.py` — Core execution service

      **Coding Standards:**
      - Async throughout — asyncio.start_unix_server, open_unix_connection
      - Pydantic v2 for all protocol models
      - structlog for logging
      - Type hints everywhere
      - Follow patterns in existing dashboard/MCP code

    output_footer: |
      ---
      **IMPORTANT:** Write your output to the specified workspace file.
      All source files must be syntactically correct and importable.
      Run tests to verify they pass before finishing.

      **LAST STEP — Return to main branch before this sheet ends:**
      ```bash
      cd /home/emzi/Projects/mozart-ai-compose
      git checkout main
      ```
      This keeps Mozart running from the stable main branch between sheets.

validations:
  - type: file_exists
    path: "{workspace}/01-ipc-design.md"
    condition: "sheet_num == 1"
  - type: content_contains
    path: "{workspace}/01-ipc-design.md"
    pattern: "IPC_DESIGN_COMPLETE"
    condition: "sheet_num == 1"

  - type: file_exists
    path: "{workspace}/02-server.md"
    condition: "sheet_num == 2"
  - type: content_contains
    path: "{workspace}/02-server.md"
    pattern: "SERVER_COMPLETE"
    condition: "sheet_num == 2"

  - type: file_exists
    path: "{workspace}/03-client.md"
    condition: "sheet_num == 3"
  - type: content_contains
    path: "{workspace}/03-client.md"
    pattern: "CLIENT_COMPLETE"
    condition: "sheet_num == 3"

  - type: file_exists
    path: "{workspace}/04-protocol.md"
    condition: "sheet_num == 4"
  - type: content_contains
    path: "{workspace}/04-protocol.md"
    pattern: "PROTOCOL_MODELS_COMPLETE"
    condition: "sheet_num == 4"

  - type: file_exists
    path: "{workspace}/05-detect-module.md"
    condition: "sheet_num == 5"
  - type: content_contains
    path: "{workspace}/05-detect-module.md"
    pattern: "DETECT_MODULE_COMPLETE"
    condition: "sheet_num == 5"

  - type: file_exists
    path: "{workspace}/06-tests.md"
    condition: "sheet_num == 6"
  - type: content_contains
    path: "{workspace}/06-tests.md"
    pattern: "TESTS_COMPLETE"
    condition: "sheet_num == 6"

  - type: file_exists
    path: "{workspace}/07-review-1.md"
    condition: "sheet_num == 7"
  - type: file_exists
    path: "{workspace}/07-review-2.md"
    condition: "sheet_num == 8"
  - type: file_exists
    path: "{workspace}/07-review-3.md"
    condition: "sheet_num == 9"

  - type: file_exists
    path: "{workspace}/08-fixes.md"
    condition: "sheet_num == 10"
  - type: content_contains
    path: "{workspace}/08-fixes.md"
    pattern: "FIXES_APPLIED"
    condition: "sheet_num == 10"

  - type: file_exists
    path: "{workspace}/09-commit.md"
    condition: "sheet_num == 11"
  - type: content_contains
    path: "{workspace}/09-commit.md"
    pattern: "COMMIT_COMPLETE"
    condition: "sheet_num == 11"

  # ═══ HARD GATES: Imports + tests pass (on daemon-symphony branch) ═══
  - type: command_succeeds
    command: "cd /home/emzi/Projects/mozart-ai-compose && git checkout daemon-symphony -q && .venv/bin/python -c 'from mozart.daemon.ipc.server import DaemonServer; from mozart.daemon.ipc.client import DaemonClient; from mozart.daemon.ipc.protocol import JsonRpcRequest, JsonRpcResponse; from mozart.daemon.detect import try_daemon_route; print(\"OK\")' ; _r=$?; git checkout main -q; exit $_r"
    condition: "sheet_num == 6"
    description: "All IPC imports succeed"
  - type: command_succeeds
    command: "cd /home/emzi/Projects/mozart-ai-compose && git checkout daemon-symphony -q && .venv/bin/pytest tests/test_daemon_ipc_*.py tests/test_daemon_cli_detection.py -q --tb=line --no-header 2>&1 | tail -1 | grep -qE '[0-9]+ passed' ; _r=$?; git checkout main -q; exit $_r"
    condition: "sheet_num == 6"
    description: "IPC unit tests pass"

  # ═══ HARD GATES: Mozart canary on main ═══
  - type: command_succeeds
    command: "cd /home/emzi/Projects/mozart-ai-compose && git checkout main -q && .venv/bin/mozart validate examples/sheet-review.yaml --json 2>/dev/null; test $? -le 1"
    condition: "sheet_num == 11"
    description: "Mozart CLI canary — main branch still works"

  # ═══ HARD GATES: Full test suite on daemon-symphony ═══
  - type: command_succeeds
    command: "cd /home/emzi/Projects/mozart-ai-compose && git checkout daemon-symphony -q && .venv/bin/pytest tests/ -x --timeout=120 -q --tb=line --no-header 2>&1 | tail -1 | grep -qE '[0-9]+ passed' ; _r=$?; git checkout main -q; exit $_r"
    condition: "sheet_num == 11"
    description: "Full test suite passes on daemon-symphony"
