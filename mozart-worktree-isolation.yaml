# ╔══════════════════════════════════════════════════════════════════════════════╗
# ║              MOZART WORKTREE ISOLATION EVOLUTION                              ║
# ║                                                                               ║
# ║  "Parallel execution requires parallel worlds"                                ║
# ║                                                                               ║
# ║  Problem: Mozart jobs that modify code cannot run in parallel safely.         ║
# ║           Multiple agents editing the same files creates race conditions.     ║
# ║           Commit validation cannot distinguish "my changes" from "others".    ║
# ║                                                                               ║
# ║  Solution: Git worktrees provide isolated working directories that share      ║
# ║            the same repository. Each Mozart job gets its own worktree.        ║
# ║                                                                               ║
# ║  Structure:                                                                   ║
# ║    Movement I   (Sheets 1-2): Discovery - Git worktrees & Mozart architecture ║
# ║    Movement II  (Sheets 3-4): Research - External patterns & design options   ║
# ║    Movement III (Sheet 5):    Synthesis - Design specification                ║
# ║    Movement IV  (Sheets 6-7): Implementation - Core feature & integration     ║
# ║    Movement V   (Sheet 8):    Validation - Testing & documentation            ║
# ║                                                                               ║
# ╚══════════════════════════════════════════════════════════════════════════════╝

name: worktree-isolation
description: |
  Implement git worktree isolation for parallel Mozart job execution.
  TDF-aligned evolution with discovery, research, synthesis, and implementation.

workspace: worktree-isolation-workspace

backend:
  type: claude_cli
  timeout_seconds: 2400
  output_format: text
  working_directory: /home/emzi/Projects/mozart-ai-compose

prompt:
  template: |
    {{ preamble }}

    {% if sheet_num == 1 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  MOVEMENT I-A: GIT WORKTREE DISCOVERY                                        ║
    ║  "Understand the tool before wielding it"                                    ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Your mission: Become an expert on git worktrees and document their capabilities,
    limitations, and implications for Mozart.

    ═══════════════════════════════════════════════════════════════════════════════
    INVESTIGATION PROTOCOL
    ═══════════════════════════════════════════════════════════════════════════════

    1. **GIT WORKTREE FUNDAMENTALS**
       ```bash
       # Read the manual
       git worktree --help 2>&1 | head -100

       # Check current worktree status
       git worktree list

       # Explore worktree structure
       ls -la .git/worktrees/ 2>/dev/null || echo "No worktrees yet"
       ```

       Questions to answer:
       - How are worktrees created? (`git worktree add`)
       - How are they removed? (`git worktree remove`)
       - What's shared between worktrees? (objects, refs)
       - What's NOT shared? (working directory, index, HEAD)

    2. **WORKTREE LIFECYCLE EXPERIMENTS**
       ```bash
       cd /home/emzi/Projects/mozart-ai-compose

       # Create a test worktree
       git worktree add /tmp/mozart-worktree-test -b test-worktree-branch 2>&1

       # Examine what was created
       ls -la /tmp/mozart-worktree-test/
       ls -la .git/worktrees/

       # Check branch status
       git branch -a | grep worktree

       # Clean up
       git worktree remove /tmp/mozart-worktree-test 2>&1
       git branch -D test-worktree-branch 2>&1
       ```

    3. **WORKTREE ISOLATION PROPERTIES**

       Investigate:
       - Can two worktrees have the same branch checked out? (No - locked)
       - What happens if a worktree path already exists?
       - How do commits in worktrees appear in main repo?
       - Can worktrees share uncommitted changes? (No - isolated)

    4. **WORKTREE EDGE CASES**

       Research:
       - What if worktree removal fails mid-operation?
       - What if the worktree branch has uncommitted changes?
       - What happens to worktrees during `git gc`?
       - How do worktrees interact with git hooks?

    ═══════════════════════════════════════════════════════════════════════════════
    OUTPUT FORMAT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/01-git-worktree-discovery.md

    ```markdown
    # Movement I-A: Git Worktree Discovery

    ## Worktree Fundamentals

    ### How Worktrees Work
    [Explanation of worktree architecture]

    ### Shared vs Isolated
    | Aspect | Shared | Isolated |
    |--------|--------|----------|
    | Git objects | ✓ | |
    | Refs/branches | ✓ | |
    | Working directory | | ✓ |
    | Index (staging) | | ✓ |
    | HEAD | | ✓ |

    ## Lifecycle Operations

    ### Creation
    - Command: `git worktree add <path> [-b <branch>]`
    - What happens: [description]
    - Time complexity: [fast/slow]

    ### Removal
    - Command: `git worktree remove <path>`
    - Prerequisites: [must be clean, etc.]
    - Cleanup: [what gets deleted]

    ## Edge Cases & Gotchas

    1. **[Edge case]**: [what happens]
    2. ...

    ## Implications for Mozart

    ### Opportunities
    - [What worktrees enable for parallel execution]

    ### Challenges
    - [What complications arise]

    ### Open Questions
    - [Things that need further investigation]
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER ({{ workspace }}/sheet1-result.md)
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 1
    PHASE: Git Worktree Discovery
    WORKTREE_COMMANDS_TESTED: [count]
    EDGE_CASES_DOCUMENTED: [count]
    IMPLICATIONS_IDENTIFIED: [count]
    KEY_FINDING: [most important discovery]
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 2 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  MOVEMENT I-B: MOZART ARCHITECTURE AUDIT                                     ║
    ║  "Know thyself before extending thyself"                                     ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Your mission: Audit Mozart's current architecture to understand where worktree
    isolation would need to integrate.

    ═══════════════════════════════════════════════════════════════════════════════
    INVESTIGATION PROTOCOL
    ═══════════════════════════════════════════════════════════════════════════════

    1. **JOB INITIALIZATION FLOW**
       ```bash
       cd /home/emzi/Projects/mozart-ai-compose

       # Find where jobs are initialized
       grep -rn "def run\|def execute\|def start" src/mozart/execution/ --include="*.py"

       # Read the main runner
       head -200 src/mozart/execution/runner.py

       # Find workspace handling
       grep -rn "workspace" src/mozart/ --include="*.py" | grep -v "__pycache__" | head -30
       ```

       Map the flow:
       - Where is workspace created?
       - When is working_directory set?
       - How does backend receive directory context?

    2. **BACKEND EXECUTION CONTEXT**
       ```bash
       # How does Claude CLI backend set working directory?
       grep -rn "working_directory\|cwd\|chdir" src/mozart/backends/ --include="*.py"

       # Read the Claude CLI backend
       cat src/mozart/backends/claude_cli.py | head -150
       ```

       Questions:
       - How is working directory passed to Claude?
       - Can this be overridden per-execution?
       - What about the Anthropic API backend?

    3. **STATE MANAGEMENT**
       ```bash
       # Where is state stored?
       grep -rn "state_path\|checkpoint\|\.json\|\.db" src/mozart/core/ --include="*.py" | head -30

       # Read checkpoint handling
       head -150 src/mozart/core/checkpoint.py
       ```

       Questions:
       - Is state stored relative to workspace or absolute?
       - Could state be stored in the worktree?
       - What happens if two jobs share state?

    4. **CONFIGURATION INTEGRATION POINTS**
       ```bash
       # Find where isolation could be configured
       grep -rn "class.*Config" src/mozart/core/config.py | head -20

       # Look at backend config specifically
       grep -A30 "class BackendConfig" src/mozart/core/config.py
       ```

       Identify:
       - Where would `isolation: worktree` config go?
       - What new config fields are needed?
       - Backward compatibility considerations?

    5. **PARALLEL EXECUTION RISKS**
       ```bash
       # Find file operations that could conflict
       grep -rn "open(\|write\|Path.*mkdir\|shutil" src/mozart/ --include="*.py" | head -30

       # Find git operations
       grep -rn "git \|\.git" src/mozart/ --include="*.py" | head -20
       ```

    ═══════════════════════════════════════════════════════════════════════════════
    OUTPUT FORMAT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/02-mozart-architecture-audit.md

    ```markdown
    # Movement I-B: Mozart Architecture Audit

    ## Job Lifecycle

    ### Initialization
    [Flow diagram or description]

    ### Execution
    [How sheets are executed]

    ### Cleanup
    [What happens on completion/failure]

    ## Integration Points for Worktrees

    | Component | File | Function | Integration Need |
    |-----------|------|----------|------------------|
    | [component] | [file:line] | [function] | [what needs to change] |

    ## Backend Context

    ### Claude CLI
    - Working directory: [how set]
    - Override mechanism: [exists/needs creation]

    ### Anthropic API
    - Working directory relevance: [N/A or relevant]

    ## State Management

    - State location: [where stored]
    - Worktree implications: [what changes needed]

    ## Configuration Schema

    ### Proposed Addition
    ```python
    class IsolationConfig(BaseModel):
        # [proposed fields]
    ```

    ## Risk Assessment

    | Risk | Likelihood | Impact | Mitigation |
    |------|------------|--------|------------|
    | [risk] | [H/M/L] | [H/M/L] | [strategy] |

    ## Architecture Diagram

    [ASCII diagram showing where worktree fits]
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER ({{ workspace }}/sheet2-result.md)
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 2
    PHASE: Mozart Architecture Audit
    COMPONENTS_ANALYZED: [count]
    INTEGRATION_POINTS: [count]
    RISKS_IDENTIFIED: [count]
    KEY_INTEGRATION_POINT: [most critical]
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 3 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  MOVEMENT II-A: EXTERNAL PATTERNS RESEARCH                                   ║
    ║  "Learn from those who walked this path before"                              ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Your mission: Research how other tools handle parallel execution isolation,
    particularly in CI/CD, build systems, and AI agent frameworks.

    ═══════════════════════════════════════════════════════════════════════════════
    RESEARCH AREAS
    ═══════════════════════════════════════════════════════════════════════════════

    1. **CI/CD SYSTEMS**

       Research how these handle parallel jobs:
       - GitHub Actions (matrix builds, job isolation)
       - GitLab CI (parallel jobs, artifacts)
       - Jenkins (workspaces, parallel stages)
       - Buildkite (agent isolation)

       Key questions:
       - Do they use worktrees, clones, or containers?
       - How do they handle shared state?
       - How do they merge results?

    2. **BUILD SYSTEMS**

       Research:
       - Bazel (sandboxing, remote execution)
       - Buck2 (isolation strategies)
       - Pants (parallel execution)
       - Gradle (parallel project builds)

       Key questions:
       - How do they isolate build artifacts?
       - How do they handle source modifications?

    3. **AI AGENT FRAMEWORKS**

       Research:
       - AutoGPT (workspace handling)
       - LangChain agents (execution context)
       - CrewAI (multi-agent coordination)
       - OpenDevin (sandbox execution)

       Key questions:
       - How do they isolate agent workspaces?
       - How do they handle file system access?

    4. **GIT WORKTREE USERS**

       Find real-world worktree usage patterns:
       - Search GitHub for "git worktree add" in CI configs
       - Look for worktree management libraries
       - Find blog posts about worktree workflows

    ═══════════════════════════════════════════════════════════════════════════════
    RESEARCH METHODS
    ═══════════════════════════════════════════════════════════════════════════════

    Use web search to find:
    - Documentation for isolation strategies
    - Blog posts about parallel execution patterns
    - GitHub discussions about worktree workflows
    - Academic papers on build isolation

    ═══════════════════════════════════════════════════════════════════════════════
    OUTPUT FORMAT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/03-external-patterns-research.md

    ```markdown
    # Movement II-A: External Patterns Research

    ## CI/CD System Patterns

    ### GitHub Actions
    [Isolation strategy, pros, cons]

    ### GitLab CI
    [Isolation strategy, pros, cons]

    ### Other Systems
    [Summary]

    ## Build System Patterns

    ### Bazel
    [Sandboxing approach]

    ### Others
    [Summary]

    ## AI Agent Framework Patterns

    ### [Framework]
    [How they handle isolation]

    ## Git Worktree Usage in the Wild

    ### Common Patterns
    [What others do with worktrees]

    ### Libraries/Tools
    [Any worktree management tools found]

    ## Pattern Comparison Matrix

    | Approach | Isolation Level | Setup Cost | Cleanup | Git Native |
    |----------|-----------------|------------|---------|------------|
    | Worktree | [level] | [cost] | [ease] | Yes |
    | Clone | [level] | [cost] | [ease] | Yes |
    | Container | [level] | [cost] | [ease] | No |

    ## Recommended Patterns for Mozart

    Based on research:
    1. [Pattern] - [why applicable]
    2. ...

    ## References

    - [URLs to key resources]
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER ({{ workspace }}/sheet3-result.md)
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 3
    PHASE: External Patterns Research
    SYSTEMS_RESEARCHED: [count]
    PATTERNS_IDENTIFIED: [count]
    WORKTREE_EXAMPLES_FOUND: [count]
    RECOMMENDED_PATTERN: [brief description]
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 4 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  MOVEMENT II-B: DESIGN OPTIONS ANALYSIS                                      ║
    ║  "Every choice closes doors; choose wisely"                                  ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Your mission: Based on discoveries so far, enumerate and analyze design options
    for implementing worktree isolation in Mozart.

    ═══════════════════════════════════════════════════════════════════════════════
    LOAD PRIOR DISCOVERIES
    ═══════════════════════════════════════════════════════════════════════════════

    Read these first:
    - {{ workspace }}/01-git-worktree-discovery.md
    - {{ workspace }}/02-mozart-architecture-audit.md
    - {{ workspace }}/03-external-patterns-research.md

    ═══════════════════════════════════════════════════════════════════════════════
    DESIGN DIMENSIONS
    ═══════════════════════════════════════════════════════════════════════════════

    Analyze options along these dimensions:

    1. **WHEN TO CREATE WORKTREE**
       - Option A: At job start (eager)
       - Option B: At first code modification (lazy)
       - Option C: Only if parallel execution detected

    2. **BRANCH STRATEGY**
       - Option A: New branch per job (`mozart/<job-id>`)
       - Option B: Detached HEAD (no branch)
       - Option C: User-specified branch

    3. **MERGE STRATEGY**
       - Option A: Auto-merge to main on success
       - Option B: Create PR automatically
       - Option C: Leave branch, manual merge
       - Option D: Cherry-pick commits to main

    4. **CLEANUP STRATEGY**
       - Option A: Always remove worktree on completion
       - Option B: Keep on failure for debugging
       - Option C: Configurable retention

    5. **CONFIGURATION API**
       - Option A: Global setting (`isolation: worktree`)
       - Option B: Per-job setting
       - Option C: Auto-detect need

    6. **ERROR HANDLING**
       - What if worktree creation fails?
       - What if merge conflicts occur?
       - What if cleanup fails?

    ═══════════════════════════════════════════════════════════════════════════════
    TDF ALIGNMENT SCORING
    ═══════════════════════════════════════════════════════════════════════════════

    Score each option combination on:
    - **COMP**: Technical complexity, integration ease
    - **SCI**: Reliability, testability, edge case handling
    - **CULT**: User experience, convention alignment
    - **EXP**: Intuitive behavior, surprise minimization

    ═══════════════════════════════════════════════════════════════════════════════
    OUTPUT FORMAT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/04-design-options-analysis.md

    ```markdown
    # Movement II-B: Design Options Analysis

    ## Prior Discoveries Summary

    Key findings from earlier sheets:
    - [Finding 1]
    - [Finding 2]

    ## Design Dimensions

    ### 1. Worktree Creation Timing

    | Option | Description | Pros | Cons | TDF Score |
    |--------|-------------|------|------|-----------|
    | Eager | Create at job start | [pros] | [cons] | C:X S:X C:X E:X |

    **Recommendation**: [option] because [reason]

    ### 2. Branch Strategy
    [Same format]

    ### 3. Merge Strategy
    [Same format]

    ### 4. Cleanup Strategy
    [Same format]

    ### 5. Configuration API
    [Same format]

    ## Composite Design Options

    ### Option Alpha: Simple & Safe
    - Creation: [choice]
    - Branch: [choice]
    - Merge: [choice]
    - Cleanup: [choice]
    - Config: [choice]

    TDF Alignment: COMP:[X] SCI:[X] CULT:[X] EXP:[X]

    ### Option Beta: Feature-Rich
    [Same format]

    ### Option Gamma: Minimal Viable
    [Same format]

    ## Recommended Design

    Based on TDF alignment and prior research, recommend:
    [Detailed recommendation with rationale]

    ## Open Questions for Synthesis

    1. [Question needing resolution]
    2. ...
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER ({{ workspace }}/sheet4-result.md)
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 4
    PHASE: Design Options Analysis
    DIMENSIONS_ANALYZED: [count]
    OPTIONS_PER_DIMENSION: [avg count]
    COMPOSITE_DESIGNS: [count]
    RECOMMENDED_DESIGN: [name/brief]
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 5 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  MOVEMENT III: DESIGN SYNTHESIS                                              ║
    ║  "From many options, one coherent design emerges"                            ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Your mission: Synthesize all discoveries and analysis into a concrete design
    specification that can guide implementation.

    ═══════════════════════════════════════════════════════════════════════════════
    LOAD ALL PRIOR WORK
    ═══════════════════════════════════════════════════════════════════════════════

    Read and synthesize:
    - {{ workspace }}/01-git-worktree-discovery.md
    - {{ workspace }}/02-mozart-architecture-audit.md
    - {{ workspace }}/03-external-patterns-research.md
    - {{ workspace }}/04-design-options-analysis.md

    ═══════════════════════════════════════════════════════════════════════════════
    SYNTHESIS TASKS
    ═══════════════════════════════════════════════════════════════════════════════

    1. **RESOLVE OPEN QUESTIONS**
       - Make decisions on any unresolved questions from prior sheets
       - Document rationale for each decision

    2. **CREATE IMPLEMENTATION SPECIFICATION**
       - Define exact config schema
       - Define exact API surface
       - Define exact file/module structure
       - Define exact error handling

    3. **CREATE INTERFACE CONTRACTS**
       ```python
       # Define the interfaces that will be implemented
       class WorktreeManager(Protocol):
           # What methods are needed?
           pass
       ```

    4. **CREATE TEST SCENARIOS**
       - Happy path: Job with worktree isolation completes
       - Error path: Worktree creation fails
       - Error path: Merge conflict
       - Cleanup: Worktree removal

    5. **CREATE IMPLEMENTATION PLAN**
       - What files need to be created?
       - What files need to be modified?
       - What order should changes be made?

    ═══════════════════════════════════════════════════════════════════════════════
    OUTPUT FORMAT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/05-design-specification.md

    ```markdown
    # Movement III: Design Specification

    ## Executive Summary

    [One paragraph describing the design]

    ## Design Decisions

    | Decision | Choice | Rationale |
    |----------|--------|-----------|
    | Creation timing | [choice] | [why] |
    | Branch strategy | [choice] | [why] |
    | Merge strategy | [choice] | [why] |
    | Cleanup strategy | [choice] | [why] |
    | Config API | [choice] | [why] |

    ## Configuration Schema

    ```python
    class IsolationConfig(BaseModel):
        """Configuration for job isolation."""

        mode: Literal["none", "worktree"] = Field(
            default="none",
            description="...",
        )
        # ... full schema
    ```

    ## Interface Specification

    ```python
    class WorktreeManager(Protocol):
        """Manages git worktree lifecycle for isolated execution."""

        async def create_worktree(
            self,
            job_id: str,
            base_branch: str | None = None,
        ) -> Path:
            """Create isolated worktree for job execution.

            Args:
                job_id: Unique job identifier for worktree naming.
                base_branch: Branch to base worktree on (default: current).

            Returns:
                Path to the created worktree.

            Raises:
                WorktreeCreationError: If worktree cannot be created.
            """
            ...

        # ... full interface
    ```

    ## File Changes

    ### New Files
    | File | Purpose | LOC Estimate |
    |------|---------|--------------|
    | src/mozart/isolation/worktree.py | WorktreeManager impl | [N] |

    ### Modified Files
    | File | Changes | LOC Estimate |
    |------|---------|--------------|
    | src/mozart/core/config.py | Add IsolationConfig | [N] |
    | src/mozart/execution/runner.py | Integrate worktree | [N] |

    ## Test Scenarios

    ### Scenario 1: Happy Path
    ```
    Given: Job configured with isolation: worktree
    When: Job executes successfully
    Then:
      - Worktree created at start
      - Execution happens in worktree
      - Changes committed in worktree
      - Branch merged to main (or PR created)
      - Worktree cleaned up
    ```

    ### Scenario 2: Creation Failure
    [Similar format]

    ## Implementation Order

    1. [First change] - [why first]
    2. [Second change] - [dependency on first]
    3. ...

    ## Risks and Mitigations

    | Risk | Mitigation |
    |------|------------|
    | [risk] | [mitigation] |
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER ({{ workspace }}/sheet5-result.md)
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 5
    PHASE: Design Synthesis
    DECISIONS_MADE: [count]
    NEW_FILES_PLANNED: [count]
    MODIFIED_FILES_PLANNED: [count]
    TEST_SCENARIOS: [count]
    ESTIMATED_TOTAL_LOC: [count]
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 6 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  MOVEMENT IV-A: CORE IMPLEMENTATION                                          ║
    ║  "The specification becomes reality"                                         ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Your mission: Implement the core worktree management functionality following
    the design specification.

    ═══════════════════════════════════════════════════════════════════════════════
    LOAD DESIGN SPECIFICATION
    ═══════════════════════════════════════════════════════════════════════════════

    Read: {{ workspace }}/05-design-specification.md

    Follow the specification exactly. If you discover issues during implementation,
    document them but proceed with the best interpretation.

    ═══════════════════════════════════════════════════════════════════════════════
    IMPLEMENTATION TASKS
    ═══════════════════════════════════════════════════════════════════════════════

    1. **CREATE ISOLATION MODULE**

       Create: `src/mozart/isolation/__init__.py`
       Create: `src/mozart/isolation/worktree.py`

       Implement:
       - WorktreeManager class
       - Error classes (WorktreeCreationError, etc.)
       - Helper functions

    2. **ADD CONFIGURATION**

       Modify: `src/mozart/core/config.py`

       Add:
       - IsolationConfig model
       - Integration into JobConfig

    3. **WRITE TESTS**

       Create: `tests/test_worktree.py`

       Test:
       - WorktreeManager.create_worktree()
       - WorktreeManager.remove_worktree()
       - Error handling
       - Edge cases from discovery

    ═══════════════════════════════════════════════════════════════════════════════
    IMPLEMENTATION PROTOCOL
    ═══════════════════════════════════════════════════════════════════════════════

    For each file:
    1. Create/modify the file
    2. Run type checker: `.venv/bin/python -m mypy <file>`
    3. Run tests: `.venv/bin/python -m pytest tests/test_worktree.py -v`
    4. Fix any issues before proceeding

    ═══════════════════════════════════════════════════════════════════════════════
    VERIFICATION
    ═══════════════════════════════════════════════════════════════════════════════

    ```bash
    cd /home/emzi/Projects/mozart-ai-compose

    # Type check new code
    .venv/bin/python -m mypy src/mozart/isolation/ --ignore-missing-imports

    # Run new tests
    .venv/bin/python -m pytest tests/test_worktree.py -v

    # Verify imports
    .venv/bin/python -c "from mozart.isolation.worktree import WorktreeManager; print('OK')"
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    COMMIT
    ═══════════════════════════════════════════════════════════════════════════════

    ```bash
    git add src/mozart/isolation/ tests/test_worktree.py src/mozart/core/config.py
    git commit -m "feat(isolation): Add WorktreeManager for parallel job execution

    - Add IsolationConfig to job configuration
    - Implement WorktreeManager with create/remove operations
    - Add comprehensive tests for worktree lifecycle
    - Handle edge cases: existing path, locked branch, cleanup failure

    Part of worktree-isolation evolution (Sheet 6/8)

    Co-Authored-By: Claude <noreply@anthropic.com>"
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    OUTPUT FORMAT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/06-core-implementation.md

    Document:
    - Files created/modified
    - Deviations from spec (if any)
    - Test results
    - Commit hash

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER ({{ workspace }}/sheet6-result.md)
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 6
    PHASE: Core Implementation
    FILES_CREATED: [count]
    FILES_MODIFIED: [count]
    TESTS_WRITTEN: [count]
    TESTS_PASSING: [yes/no]
    MYPY_PASSING: [yes/no]
    COMMIT_HASH: [hash]
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 7 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  MOVEMENT IV-B: RUNNER INTEGRATION                                           ║
    ║  "Components must connect to function"                                       ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Your mission: Integrate the WorktreeManager into Mozart's job execution flow.

    ═══════════════════════════════════════════════════════════════════════════════
    LOAD CONTEXT
    ═══════════════════════════════════════════════════════════════════════════════

    Read:
    - {{ workspace }}/05-design-specification.md (for integration points)
    - {{ workspace }}/06-core-implementation.md (for what was built)
    - src/mozart/execution/runner.py (current state)

    ═══════════════════════════════════════════════════════════════════════════════
    INTEGRATION TASKS
    ═══════════════════════════════════════════════════════════════════════════════

    1. **MODIFY RUNNER**

       In `src/mozart/execution/runner.py`:
       - Add worktree creation at job start (if isolation configured)
       - Modify backend execution to use worktree path
       - Add worktree cleanup on job completion
       - Handle worktree errors gracefully

    2. **MODIFY BACKEND**

       In `src/mozart/backends/claude_cli.py` (and others if needed):
       - Ensure working_directory override works correctly
       - Pass worktree path when isolation is active

    3. **ADD INTEGRATION TESTS**

       Create or extend tests to verify:
       - Job with isolation=worktree creates worktree
       - Execution happens in worktree
       - Cleanup occurs on success and failure

    ═══════════════════════════════════════════════════════════════════════════════
    IMPLEMENTATION PROTOCOL
    ═══════════════════════════════════════════════════════════════════════════════

    1. Read current runner.py thoroughly
    2. Identify exact integration points
    3. Make minimal, surgical changes
    4. Test after each change
    5. Ensure backward compatibility (isolation=none works as before)

    ═══════════════════════════════════════════════════════════════════════════════
    VERIFICATION
    ═══════════════════════════════════════════════════════════════════════════════

    ```bash
    cd /home/emzi/Projects/mozart-ai-compose

    # Full type check
    .venv/bin/python -m mypy src/mozart/ --ignore-missing-imports

    # Full test suite
    .venv/bin/python -m pytest tests/ -v --tb=short

    # Import check
    .venv/bin/python -c "
    from mozart.cli import app
    from mozart.execution.runner import JobRunner
    from mozart.isolation.worktree import WorktreeManager
    print('All imports OK')
    "

    # CLI smoke test
    .venv/bin/mozart --help
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    COMMIT
    ═══════════════════════════════════════════════════════════════════════════════

    ```bash
    git add -A
    git commit -m "feat(runner): Integrate worktree isolation into job execution

    - Add worktree lifecycle to JobRunner (create/cleanup)
    - Pass worktree path to backend as working_directory
    - Handle isolation errors without breaking non-isolated jobs
    - Maintain full backward compatibility

    Part of worktree-isolation evolution (Sheet 7/8)

    Co-Authored-By: Claude <noreply@anthropic.com>"
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    OUTPUT FORMAT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/07-runner-integration.md

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER ({{ workspace }}/sheet7-result.md)
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 7
    PHASE: Runner Integration
    RUNNER_CHANGES: [brief description]
    BACKEND_CHANGES: [brief description]
    TESTS_PASSING: [yes/no]
    BACKWARD_COMPATIBLE: [yes/no]
    COMMIT_HASH: [hash]
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% elif sheet_num == 8 %}
    ╔══════════════════════════════════════════════════════════════════════════════╗
    ║  MOVEMENT V: VALIDATION & DOCUMENTATION                                      ║
    ║  "The feature is not done until it's tested and documented"                  ║
    ╚══════════════════════════════════════════════════════════════════════════════╝

    Your mission: Comprehensive testing, documentation, and evolution summary.

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION TASKS
    ═══════════════════════════════════════════════════════════════════════════════

    1. **END-TO-END TEST**

       Create a test job that actually uses worktree isolation:

       ```bash
       cd /home/emzi/Projects/mozart-ai-compose

       # Create a simple test job config
       cat > {{ workspace }}/test-isolation-job.yaml << 'EOF'
       name: test-isolation
       description: Test worktree isolation
       workspace: {{ workspace }}/test-run

       backend:
         type: claude_cli
         timeout_seconds: 120
         working_directory: /home/emzi/Projects/mozart-ai-compose

       # Enable isolation (if implemented)
       isolation:
         mode: worktree

       prompt:
         template: |
           Create a file called {{ workspace }}/test-run/isolation-test.txt
           containing "Worktree isolation works!"

       sheet:
         total_items: 1
         size: 1

       validations:
         - type: file_exists
           path: "{workspace}/isolation-test.txt"
       EOF
       ```

       Run and verify (or document what would need to happen).

    2. **REGRESSION TESTING**

       Verify existing jobs still work without isolation:
       ```bash
       # Run a simple validation
       .venv/bin/mozart validate examples/sheet-review.yaml

       # Dry run
       .venv/bin/mozart run examples/sheet-review.yaml --dry-run
       ```

    3. **DOCUMENTATION**

       Update relevant documentation:
       - Add section to CLAUDE.md about worktree isolation
       - Update examples/ with isolation example
       - Document configuration options

    ═══════════════════════════════════════════════════════════════════════════════
    EVOLUTION SUMMARY
    ═══════════════════════════════════════════════════════════════════════════════

    Write comprehensive summary of the evolution:
    - What was discovered
    - What was designed
    - What was implemented
    - What remains for future work

    ═══════════════════════════════════════════════════════════════════════════════
    FINAL COMMIT
    ═══════════════════════════════════════════════════════════════════════════════

    ```bash
    git add -A
    git commit -m "docs(isolation): Complete worktree isolation evolution

    Evolution summary:
    - Discovered: [key git worktree findings]
    - Designed: [key design decisions]
    - Implemented: [what was built]
    - Tested: [test coverage]

    This enables parallel Mozart job execution with proper isolation.

    Co-Authored-By: Claude <noreply@anthropic.com>"
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    OUTPUT FORMAT
    ═══════════════════════════════════════════════════════════════════════════════

    Write to: {{ workspace }}/08-evolution-summary.md

    ```markdown
    # Worktree Isolation Evolution Summary

    ## Problem Statement

    [Why this feature was needed]

    ## Discovery Phase Findings

    ### Git Worktrees
    [Key learnings]

    ### Mozart Architecture
    [Integration points identified]

    ### External Patterns
    [What others do]

    ## Design Decisions

    | Decision | Choice | Rationale |
    |----------|--------|-----------|
    | [decision] | [choice] | [why] |

    ## Implementation Summary

    ### Files Created
    - [file]: [purpose]

    ### Files Modified
    - [file]: [changes]

    ### Test Coverage
    - [test]: [what it tests]

    ## Verification Results

    - Type checking: [pass/fail]
    - Unit tests: [X passed]
    - Integration tests: [status]
    - Backward compatibility: [verified/issues]

    ## Future Work

    1. [Enhancement]: [description]
    2. ...

    ## Lessons Learned

    1. [Lesson]: [insight]
    2. ...
    ```

    ═══════════════════════════════════════════════════════════════════════════════
    VALIDATION MARKER ({{ workspace }}/sheet8-result.md)
    ═══════════════════════════════════════════════════════════════════════════════
    ```
    SHEET: 8
    PHASE: Validation & Documentation
    E2E_TEST_STATUS: [pass/fail/deferred]
    REGRESSION_STATUS: [pass/fail]
    DOCS_UPDATED: [yes/no]
    FINAL_COMMIT_HASH: [hash]
    EVOLUTION_COMPLETE: yes
    IMPLEMENTATION_COMPLETE: yes
    ```

    {% endif %}

    {{ stakes }}

  variables:
    preamble: |
      ╔══════════════════════════════════════════════════════════════════════════╗
      ║              MOZART WORKTREE ISOLATION EVOLUTION                          ║
      ╚══════════════════════════════════════════════════════════════════════════╝

      You are executing a TDF-aligned evolution to add worktree isolation to Mozart.

      PROBLEM: Mozart jobs that modify code cannot run safely in parallel. Multiple
      jobs editing files create race conditions. Commit validation can't distinguish
      "my changes" from changes made by parallel jobs.

      SOLUTION: Git worktrees provide isolated working directories. Each job gets
      its own worktree with its own working directory, index, and HEAD.

      CURRENT SHEET: {{ sheet_num }} of 8
      WORKSPACE: {{ workspace }}

      PROJECT: /home/emzi/Projects/mozart-ai-compose

    stakes: |
      ═══════════════════════════════════════════════════════════════════════════
      STAKES
      ═══════════════════════════════════════════════════════════════════════════

      Without worktree isolation, Mozart is fundamentally limited:
      - Only one job can safely modify code at a time
      - Commit validation is sketchy and unreliable
      - Parallel execution is a footgun waiting to fire

      With worktree isolation, Mozart becomes production-grade:
      - Multiple jobs can run in parallel safely
      - Each job has its own isolated workspace
      - Commits are clean and attributable
      - Enterprise-ready orchestration

      This evolution transforms Mozart from a single-threaded tool to a
      truly parallel orchestration system.

sheet:
  total_items: 8
  size: 1

retry:
  max_retries: 3
  base_delay_seconds: 60

validations:
  # ═══════════════════════════════════════════════════════════════════════════
  # MOVEMENT I: Discovery
  # ═══════════════════════════════════════════════════════════════════════════

  - type: file_exists
    path: "{workspace}/01-git-worktree-discovery.md"
    description: "Git worktree discovery document exists"
    condition: "sheet_num >= 1"

  - type: content_contains
    path: "{workspace}/01-git-worktree-discovery.md"
    pattern: "Implications for Mozart"
    description: "Discovery includes Mozart implications"
    condition: "sheet_num >= 1"

  - type: file_exists
    path: "{workspace}/02-mozart-architecture-audit.md"
    description: "Mozart architecture audit exists"
    condition: "sheet_num >= 2"

  - type: content_contains
    path: "{workspace}/02-mozart-architecture-audit.md"
    pattern: "Integration Points"
    description: "Audit identifies integration points"
    condition: "sheet_num >= 2"

  # ═══════════════════════════════════════════════════════════════════════════
  # MOVEMENT II: Research
  # ═══════════════════════════════════════════════════════════════════════════

  - type: file_exists
    path: "{workspace}/03-external-patterns-research.md"
    description: "External patterns research exists"
    condition: "sheet_num >= 3"

  - type: content_contains
    path: "{workspace}/03-external-patterns-research.md"
    pattern: "Recommended"
    description: "Research includes recommendations"
    condition: "sheet_num >= 3"

  - type: file_exists
    path: "{workspace}/04-design-options-analysis.md"
    description: "Design options analysis exists"
    condition: "sheet_num >= 4"

  - type: content_contains
    path: "{workspace}/04-design-options-analysis.md"
    pattern: "TDF"
    description: "Design analysis uses TDF alignment"
    condition: "sheet_num >= 4"

  # ═══════════════════════════════════════════════════════════════════════════
  # MOVEMENT III: Synthesis
  # ═══════════════════════════════════════════════════════════════════════════

  - type: file_exists
    path: "{workspace}/05-design-specification.md"
    description: "Design specification exists"
    condition: "sheet_num >= 5"

  - type: content_contains
    path: "{workspace}/05-design-specification.md"
    pattern: "Interface Specification"
    description: "Spec includes interface definition"
    condition: "sheet_num >= 5"

  - type: content_contains
    path: "{workspace}/05-design-specification.md"
    pattern: "Implementation Order"
    description: "Spec includes implementation plan"
    condition: "sheet_num >= 5"

  # ═══════════════════════════════════════════════════════════════════════════
  # MOVEMENT IV: Implementation
  # ═══════════════════════════════════════════════════════════════════════════

  - type: file_exists
    path: "{workspace}/06-core-implementation.md"
    description: "Core implementation report exists"
    condition: "sheet_num >= 6"

  - type: content_regex
    path: "{workspace}/sheet6-result.md"
    pattern: "TESTS_PASSING: yes"
    description: "Core implementation tests pass"
    condition: "sheet_num >= 6"

  - type: file_exists
    path: "{workspace}/07-runner-integration.md"
    description: "Runner integration report exists"
    condition: "sheet_num >= 7"

  - type: content_regex
    path: "{workspace}/sheet7-result.md"
    pattern: "BACKWARD_COMPATIBLE: yes"
    description: "Integration maintains backward compatibility"
    condition: "sheet_num >= 7"

  # ═══════════════════════════════════════════════════════════════════════════
  # MOVEMENT V: Validation
  # ═══════════════════════════════════════════════════════════════════════════

  - type: file_exists
    path: "{workspace}/08-evolution-summary.md"
    description: "Evolution summary exists"
    condition: "sheet_num >= 8"

  - type: content_regex
    path: "{workspace}/sheet8-result.md"
    pattern: "EVOLUTION_COMPLETE: yes"
    description: "Evolution marked complete"
    condition: "sheet_num >= 8"

  # ═══════════════════════════════════════════════════════════════════════════
  # GLOBAL VALIDATIONS
  # ═══════════════════════════════════════════════════════════════════════════

  - type: file_exists
    path: "{workspace}/sheet{sheet_num}-result.md"
    description: "Sheet result file exists"

  - type: content_contains
    path: "{workspace}/sheet{sheet_num}-result.md"
    pattern: "IMPLEMENTATION_COMPLETE: yes"
    description: "Sheet marked complete"

  # Implementation verification (sheets 6+)
  - type: command_succeeds
    description: "No import errors after implementation"
    command: cd /home/emzi/Projects/mozart-ai-compose && .venv/bin/python -c "from mozart.cli import app; from mozart.execution.runner import JobRunner"
    condition: "sheet_num >= 6"

  - type: command_succeeds
    description: "Tests still pass after implementation"
    # Note: Ignoring test_runner.py due to hanging tests (TestRunnerReturnsRunSummary)
    command: cd /home/emzi/Projects/mozart-ai-compose && .venv/bin/python -m pytest tests/ -q --tb=no --ignore=tests/test_runner.py 2>&1 | tail -3 | grep -qE "passed|no tests"
    condition: "sheet_num >= 6"

learning:
  enabled: true

cost_limits:
  enabled: false
