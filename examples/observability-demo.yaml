# Example: Observability Demo Job
# Demonstrates Mozart's observability features: logging, error tracking, diagnostics

name: "observability-demo"
description: "Demo job showcasing observability features"

workspace: "./observability-workspace"

# Backend configuration
backend:
  type: claude_cli
  skip_permissions: true
  timeout_seconds: 300  # 5 minute timeout per batch

# Simple batch setup for demo
batch:
  size: 5
  total_items: 15  # 3 batches total

# Simple prompt template
prompt:
  template: |
    Process batch {{ batch_num }} of {{ total_batches }}.

    Create a file at {{ workspace }}/batch{{ batch_num }}-output.md containing:
    - A summary of items {{ start_item }} to {{ end_item }}
    - A timestamp of when processing completed
    - Any observations about the batch

    {{ stakes }}

  stakes: "Complete all items with thorough output."

# Retry configuration with observable settings
retry:
  max_retries: 3
  base_delay_seconds: 10
  max_delay_seconds: 300
  exponential_base: 2.0
  jitter: true
  # Partial completion recovery
  max_completion_attempts: 2
  completion_delay_seconds: 5
  completion_threshold_percent: 50.0

# Rate limit handling
rate_limit:
  wait_minutes: 60
  max_waits: 24
  detection_patterns:
    - "rate.?limit"
    - "usage.?limit"
    - "quota"
    - "429"
    - "capacity"

# Validations - each generates diagnostic data on failure
validations:
  - type: file_exists
    path: "{workspace}/batch{batch_num}-output.md"
    description: "Batch output file must exist"

  - type: content_contains
    path: "{workspace}/batch{batch_num}-output.md"
    pattern: "Summary"
    description: "Output must contain Summary section"

# ============================================================
# OBSERVABILITY CONFIGURATION
# ============================================================

# Structured logging configuration
logging:
  level: DEBUG              # Capture all log levels for debugging
  format: both              # Console + file output
  file_path: observability-workspace/logs/mozart.log
  max_file_size_mb: 50      # Rotate at 50MB
  backup_count: 5           # Keep 5 compressed backups
  include_timestamps: true  # Add timestamps to all entries
  include_context: true     # Add job_id, run_id, batch_num to logs

# Notifications for observability
notifications:
  - type: desktop
    on_events: [job_complete, job_failed, batch_failed]

# State backend (JSON for easy inspection)
state_backend: json

# Pause between batches (helps with debugging)
pause_between_batches_seconds: 5

# ============================================================
# USAGE: Observability Features Demo
# ============================================================
#
# 1. RUN THE JOB:
#    mozart run examples/observability-demo.yaml
#
# 2. WHILE RUNNING, tail logs:
#    mozart logs -f
#    mozart logs --level DEBUG
#
# 3. AFTER COMPLETION, view diagnostics:
#    mozart diagnose observability-demo
#    mozart diagnose observability-demo --include-output
#    mozart diagnose observability-demo --json
#
# 4. VIEW ERROR HISTORY:
#    mozart errors observability-demo
#    mozart errors --code E001
#    mozart errors --verbose
#
# 5. CHECK RAW LOG FILES:
#    cat observability-workspace/logs/mozart.log
#    zcat observability-workspace/logs/mozart.log.1.gz
#
# 6. INSPECT STATE FILE (JSON backend):
#    cat ~/.mozart/state/observability-demo.json | jq '.batches'
#    cat ~/.mozart/state/observability-demo.json | jq '.batches."1".error_history'
#    cat ~/.mozart/state/observability-demo.json | jq '.batches."1".prompt_metrics'
#
# ============================================================
# WHAT TO OBSERVE
# ============================================================
#
# - Structured logs with context (job_id, batch_num, run_id)
# - Error classification with error codes (E001, E101, etc.)
# - Prompt metrics (estimated tokens, line count)
# - Preflight warnings (if prompt is large)
# - Raw output capture (last 10KB in batch state)
# - Error history with stack traces
# - Execution timing per batch
# - Exit signal differentiation (SIGTERM vs SIGKILL)
# - Circuit breaker status
# - Log rotation and compression
